<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Atcoder agc027 B] Garbage Collector]]></title>
    <url>%2F2019%2F03%2F13%2FAtcoder-agc027-B-Garbage-Collector%2F</url>
    <content type="text"><![CDATA[题目链接Atcoder agc027 B 题目大意现在有一条数轴，数轴上有$n$个点存在垃圾，有个捡垃圾的机器人从$0$号点出发，现在需要将所有垃圾运回$0$号点。捡起一个垃圾需要消耗$X$能量，当身上有$k$个垃圾时，走一步需要消耗$(k+1)^2$能量。回到起点倒一次垃圾也需要消耗$X$能量，注意这里倒垃圾时不管身上运载着多少垃圾，消耗能量均为$X$。$n \le 2*10^5$ 做法感觉上很像$dp+$斜率优化。但是这题有个非常关键的地方，每次出发所捡的垃圾并不一定相邻。手动模拟一下，假设一次出发经过了$t_q,t_{q-1},t_{q-2}…t_1$点的话。所需要的能量就是$X(q+1)+5t_1+5t_2+7t_3+9t_4…$假设我们一共出发$A$次的话，那么最远的$2A$个点会有$5$的贡献，再近一点的$A$个点有$7$的贡献，再近一点的$A$个点有$9$的贡献，以此类推。最后再加上倒$A$次垃圾，捡$n$次垃圾的贡献$(A+n)*X$即可。发现算这个贡献的复杂度其实是调和级数的，我们先预处理一下前缀和，暴力枚举$A$，暴力计算就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (200005)using namespace std;int n,tt;LL a[N],sum[N];LL ans=9e18,x,now; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(n),read(x); for (int i=1;i&lt;=n;i++) read(a[i]),sum[i]=sum[i-1]+a[i]; for (int i=1;i&lt;=n;i++)&#123; now=x*(i+n); tt=3; for (int j=n;j&gt;=1;j-=i)&#123; if (tt==3) now+=(sum[j]-sum[max(0,j-i)])*5; else now+=(sum[j]-sum[max(0,j-i)])*tt; tt+=2; if (now&gt;=ans) break; &#125; ans=min(ans,now); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二类斯特林数学习笔记]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二类斯特林数定义第二类斯特林数$S(n,m)$定义为把$n$个球放入$m$个盒子中，所有盒子均不为空的方案数，其中球不带标号，而盒子是带标号的。 递推求法根据定义，就能得到第二类斯特林数的递推求法，只需要枚举最后一个球放在哪个集合里即可。 S(n,m)=S(n-1,m-1)+m*S(n-1,m) 组合求法而第二类斯特林数还可以用组合意义来求得。假设我们现在有$n$个无标号球，随意放在$m$个带标号的盒子中，显然方案数可以为$m^n$而我们再枚举有几个非空盒子，用第二类斯特林数计算，可以得到 m^n=\sum_{i=0}^{m}\binom{m}{i}*S(n,i)*i!这个式子是一个二项式反演的经典式子，我们二项式反演一下 S(n,m)*m!=\sum_{j=0}^{m}(-1)^{m-j}*j^n*\binom{m}{j}快速求$S(n,1..m)$发现上面组合求法中，可以把第二类斯特林数写成卷积的形式。 S(n,m)*m!=\sum_{i=0}^{m}(-1)^{m-j}*j^n*\frac{m!}{j!*(m-j)!}S(n,m)=\sum_{i=0}^{m}(-1)^{m-j}*j^n*\frac{1}{j!*(m-j)!}令$A(x)=\frac{(-1)^x}{x!},B(x)=\frac{x^n}{x!}$$S(n,m)=A(m-j)*B(j)$用$NTT/FFT$就可以在$O(n*logn)$的时间内求出。 例题题目链接BZOJ 5093 做法显然每个点的贡献是独立的，考虑每个点的贡献，枚举有几条边与他相连，其他与他不相连的边随便。 ans=n*2^{\binom{n-1}{2}}\sum_{i=0}^{n-1}i^k*\binom{n-1}{i}由于有$n$个点，所以乘个$n$就好了。定义$f(n,m)$为$\sum\limits_{i=0}^{n}i^m*\binom{n}{i}$我们只有求出$f(n-1,k)$上面的问题就能解决了。根据我们前面的式子，上面的$i^m$可以用斯特林数展开。 f(n,m)=\sum_{i=0}^{n}\sum_{j=0}^{i}*\binom{i}{j}*S(m,j)*j!*\binom{n}{i}改为先枚举$j$ f(n,m)=\sum_{j=0}^{i}S(m,j)*j!\sum_{i=0}^{n}\binom{n}{i}*\binom{i}{j}观察一下后面这个$\sum\limits_{i=0}^{n}\binom{n}{i}*\binom{i}{j}$是什么可以看成在$n$个物品中选出$j$个，剩下的随意，那么 \sum_{i=0}^{n}\binom{i}{j}*\binom{n}{i}=\binom{n}{j}*2^{n-j}所以 f(n,m)=\sum_{j=0}^{i}S(m,j)*j!\binom{n}{j}*2^{n-j}这样的话我们在用$NTT$算出第二类斯特林数，剩下的项都可以快速算出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1000005)using namespace std;const int P=998244353;int n,k,lim,d,invL,tot,CC,mi,inv2;int f[N&lt;&lt;1],g[N&lt;&lt;1],R[N&lt;&lt;1],A[N],inv[N],jc[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline void NTT(int *f,int G)&#123; for (int i=0;i&lt;lim;i++)&#123; if (i&gt;R[i]) swap(f[i],f[R[i]]); &#125; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; int w0=ksm(G,(P-1)/(i&lt;&lt;1)); for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; int w=1; for (int k=j;k&lt;j+i;k++)&#123; int t=1ll*f[k+i]*w%P; f[k+i]=Inc(f[k],P-t); f[k]=Inc(f[k],t); w=1ll*w*w0%P; &#125; &#125; &#125; if (G!=3)&#123; for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*invL%P; &#125;&#125;int C(int a,int b)&#123; return 1ll*jc[a]*inv[a-b]%P*inv[b]%P;&#125;int main()&#123; read(n),read(k); if (k==0)&#123; printf("%lld",1ll*ksm(2,n-1)*n%P*ksm(2,1ll*(n-1)*(n-2)/2%(P-1))%P); return 0; &#125; for (lim=1;lim&lt;2*k+2;lim&lt;&lt;=1); invL=ksm(lim,P-2); for (int i=0;i&lt;lim;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*lim&gt;&gt;1); A[0]=A[1]=1; for (int i=2;i&lt;=k;i++) A[i]=1ll*(P-P/i)*A[P%i]%P; inv[0]=1; for (int i=1;i&lt;=k;i++) inv[i]=1ll*inv[i-1]*A[i]%P; jc[0]=1; for (int i=1;i&lt;=k;i++) jc[i]=1ll*jc[i-1]*i%P; f[0]=1; g[0]=0; d=1; for (int i=1;i&lt;=k;i++)&#123; d=P-d; f[i]=1ll*d*inv[i]%P; g[i]=1ll*ksm(i,k)*inv[i]%P; &#125; NTT(f,3),NTT(g,3); for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*g[i]%P; NTT(f,ksm(3,P-2)); CC=1; mi=ksm(2,n-1); inv2=ksm(2,P-2); for (int j=0;j&lt;=min(n-1,k);j++)&#123; tot=Inc(tot,1ll*f[j]*CC%P*jc[j]%P*mi%P); CC=1ll*CC*A[j+1]%P*(n-j-1)%P; mi=1ll*mi*inv2%P; &#125; printf("%lld",1ll*tot*n%P*ksm(2,1ll*(n-1)*(n-2)/2%(P-1))%P); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1085] [SCOI2005]骑士精神]]></title>
    <url>%2F2019%2F03%2F02%2FBZOJ-1085-SCOI2005-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[前言现在的$OI$这种搜索题已经很久没有出现过了，也只有在刷前些年的题才能看到了。 题目链接BZOJ 1085 做法第一反应想到状压，但是状态数至少也是$\binom{25}{12}*25$，是在太大了。那只能搜索了，看到这道题显然是一个迭代加深的模型，所以我们考虑用$IDA^*$来解决。考虑如何构造估价函数，最优情况下，我们每次能把一个黑棋或者白棋直接移到我们想要的位置上，所以我们对比一下期望棋盘和现在棋盘有几个位置不一样就行了。注意要把空格的贡献去掉，因为一次移动可能是空格和最后一个棋子同时归位。那么接下来就是直接暴力搜索，枚举跳哪个骑士并不好，我们改为枚举跳空格就行了。具体实现的话可以见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int T,stx,sty,maxdep;bool flag;const int goal[6][6]=&#123; &#123;0,0,0,0,0,0&#125;, &#123;0,1,1,1,1,1&#125;, &#123;0,0,1,1,1,1&#125;, &#123;0,0,0,2,1,1&#125;, &#123;0,0,0,0,0,1&#125;, &#123;0,0,0,0,0,0&#125;,&#125;;const int dx[10]=&#123;-2,-1,1,2,2,1,-1,-2&#125;;const int dy[10]=&#123;1,2,2,1,-1,-2,-2,-1&#125;;int a[6][6];inline int calc()&#123; int ret=0; for (int i=1;i&lt;=5;i++)&#123; for (int j=1;j&lt;=5;j++) ret+=(goal[i][j]!=a[i][j]); &#125; return ret;&#125;inline bool safe(int x,int y)&#123; return x&gt;=1&amp;&amp;x&lt;=5&amp;&amp;y&gt;=1&amp;&amp;y&lt;=5;&#125; char c[10];inline void IDAx(int u,int x,int y)&#123; if (u&gt;maxdep)&#123; if (!calc()) flag=1; return; &#125; for (int i=0;i&lt;=7;i++)&#123; if (flag) return; if (safe(x+dx[i],y+dy[i]))&#123; swap(a[x][y],a[x+dx[i]][y+dy[i]]); x=x+dx[i],y=y+dy[i]; if (calc()+u-1&lt;=maxdep) IDAx(u+1,x,y); x-=dx[i],y-=dy[i]; swap(a[x][y],a[x+dx[i]][y+dy[i]]); &#125; &#125;&#125;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(T); while (T--)&#123; for (int i=1;i&lt;=5;i++)&#123; scanf("%s",c+1); for (int j=1;j&lt;=5;j++)&#123; if (c[j]=='*')&#123; stx=i,sty=j; a[i][j]=2; &#125; else a[i][j]=c[j]-'0'; &#125; &#125; flag=0; for (maxdep=1;maxdep&lt;=15;maxdep++)&#123; IDAx(1,stx,sty); if (flag)&#123; printf("%d\n",maxdep); break; &#125; &#125; if (!flag) puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 2496] [SDOI 2012] 体育课]]></title>
    <url>%2F2019%2F03%2F01%2FLuogu-2496-SDOI-2012-%E4%BD%93%E8%82%B2%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 2496 题目大意维护一个长度为$n$的数列，并进行$m$次操作，操作一共有三类。(1) 询问区间最大值(2) 交换数列的两个位置(3) 区间加等差数列$n,m\le 10^5$ 做法看到这种区间的题，第一反应会想到线段树，但是冷静一下发现线段树不太行，注意到数据范围是允许$\sqrt{n}$过的，我们考虑一下分块。我们把每个点看成一个形如$kx+b$的形式，那么区间加等差数列的的话，可以看成是改变了一段区间的$x$当$x$改变时，答案实际上是在这个区间的下凸壳上移动的。对于点$i$，我们将他的高度看成一个一次函数$y=ix+b$。将序列分块，对每个块维护这个块的下凸壳，以及这个区间的$x$和区间加常数标记$lazy$查询的时候，对于整块，我们只要在单调栈上二分一下，再加上这个块的$lazy$就行了。对于非整块，直接暴力计算即可。区间加等差数列是，如果加在整块上，在这个区间的$x$上加一下，$lazy$标记里把多加的减掉就行了。对于非整块，先暴力修改单点的$b$，再对于所有有部分被修改的块暴力重构。暴力重构的复杂度为$O(\sqrt n)$，而每次修改最多只会重构两个块，所以总复杂度仍是$O(n\sqrt n)$对于交换两个位置的操作，我们先把这两个数所在的块的标记暴力改到每个点上，交换这两个点的$b$之后，再暴力重构这两个块就行了，复杂度与上一步一样。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)#define M (355)using namespace std;int n,m,unit,tot,op,l,r,t; int st[M],en[M],be[N],top[M],now[M],sta[M][M];LL lazy[N],x[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;struct line&#123; int k; LL b;&#125;a[N];inline bool work(line a,line b,line c)&#123; return 1ll*(a.b-b.b)*(c.k-b.k)&gt;=1ll*(b.b-c.b)*(b.k-a.k);&#125;inline void push(int u)&#123; for (int i=st[u];i&lt;=en[u];i++) a[i].b+=1ll*a[i].k*x[u]+lazy[u]; lazy[u]=0,x[u]=0;&#125;inline void reset(int u)&#123; push(u); top[u]=0; sta[u][++top[u]]=st[u]; if (st[u]&lt;en[u])&#123;sta[u][++top[u]]=st[u]+1;&#125; for (int i=st[u]+2;i&lt;=en[u];i++)&#123; while (top[u]&gt;1&amp;&amp;work(a[sta[u][top[u]-1]],a[sta[u][top[u]]],a[i])) top[u]--; sta[u][++top[u]]=i; &#125; now[u]=1;&#125;LL get(int u)&#123; return 1ll*a[u].k*x[be[u]]+a[u].b+lazy[be[u]];&#125;inline void change(int L,int R,int t)&#123; if (be[L]==be[R])&#123; for (int i=L;i&lt;=R;i++) a[i].b+=1ll*t*(i-L+1); reset(be[L]); &#125; else&#123; for (int i=be[L]+1;i&lt;=be[R]-1;i++)&#123; x[i]+=t; lazy[i]+=1ll*(1-L)*t; &#125; for (int i=L;i&lt;=en[be[L]];i++) a[i].b+=1ll*t*(i-L+1); reset(be[L]); for (int i=st[be[R]];i&lt;=R;i++) a[i].b+=1ll*t*(i-L+1); reset(be[R]); &#125;&#125;inline LL query(int L,int R)&#123; LL maxx=0; if (be[L]==be[R])&#123; for (int i=L;i&lt;=R;i++) maxx=max(get(i),maxx); &#125; else&#123; for (int i=be[L]+1;i&lt;=be[R]-1;i++)&#123; for (int j=1;j&lt;=top[i];j++) maxx=max(maxx,get(sta[i][j])); &#125; for (int i=L;i&lt;=en[be[L]];i++) maxx=max(maxx,get(i)); for (int i=st[be[R]];i&lt;=R;i++) maxx=max(maxx,get(i)); &#125; maxx=max(0ll,maxx-get(1)); return maxx;&#125;int main()&#123; read(n),read(m); unit=sqrt(n); for (int i=1;i&lt;=n;i++)&#123; be[i]=(i-1)/unit+1; if (be[i]!=be[i-1])&#123; en[be[i-1]]=i-1; st[be[i]]=i; &#125; &#125; tot=be[n]; en[tot]=n; for (int i=1;i&lt;=n;i++)&#123; read(a[i].b); a[i].k=i; &#125; for (int i=1;i&lt;=tot;i++) reset(i); while (m--)&#123; read(op); if (op==1)&#123; read(l),read(r); printf("%lld\n",query(l,r)); &#125; if (op==2)&#123; read(l),read(r); push(be[l]),push(be[r]); swap(a[l].b,a[r].b); reset(be[l]),reset(be[r]); &#125; if (op==3)&#123; read(l),read(r),read(t); change(l,r,t); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF 1129 D] Isolation]]></title>
    <url>%2F2019%2F02%2F28%2FCF-1129-D-Isolation%2F</url>
    <content type="text"><![CDATA[题目链接CF 1129 D 题目大意现在有一个数列，长度为$n$，其中每个数均$\le n$，要求把数列分成若干段，使得这个数列每段中只出现$1$次的数均不超过$k$个。$k \le n \le 10^5$ 做法首先$n^2$的$dp$非常显然。 f_i=\sum_{j=0}^{i-1}f_j*[区间[j+1,i]中仅出现一次的数的个数\le k]我们考虑构造一个序列$v$，$\sum\limits_{i=l}^{r}v_i$表示区间$[l,r]$中仅出现一次的数的个数。考虑如何构造$v$我们每次新加进来一个数，$v_i=1$，$v_{pre[i]}=-1$，$v_{pre[pre[i]]}=0$，$pre[i]$是所有位置上的数与我相同的位置中最靠近我的一个，当然，是在我前面。我们在对$v$做一次前缀和，得到数组$S$，那么我们上面的式子可以改写为 f_i=\sum_{j=0}^{i-1}f_j*[S_i-S_j\le k]f_i=\sum_{j=0}^{i-1}f_j*[S_j\ge S_i-k]把问题转化一下。维护一个数列，支持区间加，以及区间查询$S$小于一个数的$f$的和。我们对原序列分块，每个块内维护权值的后缀和，我们对于每个区间用一个$lazy$标记维护整个块都加的值。如果有一个块有一部分被修改了，我们就暴力重构整一个块，所以每次修改的复杂度是$O(块大小)+O(块数)$，可以做到$\sqrt n$。询问的时候，如果是整块，那么就先处理一下$lazy$标记，再在后缀和上查询一下就好了。非整块部分暴力即可。这题还有一些比较好的性质，我们每次插入一个数都只会改变最多两个区间的$S$值。此外，在块内维护后缀和的时候还有一些小$tips$，发现$abs(S_i-S_{i-1})\le 1$的，所以我们把一个块内所有的$S$值，都减去最小的$S$值，那么$S$的区间是不会超过块大小的。最后在在整个区间的$lazy$标记上把减去的那个数加回来就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,k,unit,tot;int be[N],st[N],en[N],a[N],sum[2055][2055],f[N],pre[N],now[N],lazy[N],S[N];const int P=998244353; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void reset(int u)&#123; for (int i=st[u];i&lt;=en[u];i++) S[i]+=lazy[u]; lazy[u]=0; int minn=S[st[u]]; for (int i=st[u];i&lt;=en[u];i++) minn=min(minn,S[i]); for (int i=st[u];i&lt;=en[u];i++) S[i]-=minn; memset(sum[u],0,sizeof(sum[u])); for (int i=st[u];i&lt;=en[u];i++) sum[u][S[i]]=Inc(sum[u][S[i]],f[i]); for (int i=unit-1;i&gt;=0;i--) sum[u][i]=Inc(sum[u][i],sum[u][i+1]); lazy[u]=minn;&#125;void change(int L,int R,int data)&#123; if (be[L]==be[R])&#123; for (int i=L;i&lt;=R;i++) S[i]+=data; reset(be[L]); &#125; else&#123; for (int i=be[L]+1;i&lt;=be[R]-1;i++) lazy[i]+=data; for (int i=L;i&lt;=en[be[L]];i++) S[i]+=data; reset(be[L]); for (int i=st[be[R]];i&lt;=R;i++) S[i]+=data; reset(be[R]); &#125;&#125;int query(int R,int lim)&#123; //printf("query %d %d\n",R,lim); if (R==0) return 0; int ret=0; for (int i=1;i&lt;be[R];i++)&#123; if (lim-lazy[i]&gt;unit) continue; ret=Inc(ret,sum[i][max(lim-lazy[i],0)]); &#125; for (int i=st[be[R]];i&lt;=R;i++)&#123; if (S[i]+lazy[be[i]]&gt;=lim) ret=Inc(ret,f[i]); &#125; //for (int i=1;i&lt;=R;i++)&#123; // if (S[i]+lazy[be[i]]&gt;=lim) ret=Inc(ret,f[i]); //&#125; return ret;&#125;int main()&#123; read(n),read(k); unit=sqrt(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i]); pre[i]=now[a[i]]; now[a[i]]=i; &#125; for (int i=1;i&lt;=n;i++)&#123; be[i]=(i-1)/unit+1; if (be[i]!=be[i-1])&#123; en[be[i-1]]=i-1; st[be[i]]=i; &#125; &#125; tot=be[n]; en[tot]=n; f[0]=1; S[0]=0; for (int i=1;i&lt;=n;i++)&#123; if (be[i-1]!=be[i]) S[i]=S[i-1]+1+lazy[be[i-1]]; else S[i]=S[i-1]+1; if (pre[pre[i]]) change(pre[pre[i]],i,1); if (pre[i]) change(pre[i],i,-2); f[i]=query(i-1,S[i]+lazy[be[i]]-k); if (S[i]+lazy[be[i]]&lt;=k) f[i]++; if (i==en[be[i]]) reset(be[i]); &#125; printf("%d",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>CF</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1043] [HAOI2008]下落的圆盘]]></title>
    <url>%2F2019%2F02%2F27%2FBZOJ-1043-HAOI2008-%E4%B8%8B%E8%90%BD%E7%9A%84%E5%9C%86%E7%9B%98%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1043 做法博主的计算几何是在是太差了，只能做做这种入门题。我们发现$n$的范围并不大，我们可以考虑对于每个圆，算出后面每个圆覆盖他的部分。覆盖他的部分我们把弧对应到圆心角的一个区间。加入我们现在要算圆$i$被圆$j$覆盖的圆心角的区间。首先先特判圆$i$和圆$j$相离，以及圆$j$被圆$i$包含的情况。如果圆$i$被圆$j$包含，那么$i$圆心角整个区间被覆盖。我们画个图可以发现，$i$的圆心，两圆的一个交点，$j$的圆心，构成一个三角形。用余弦定理可以算出角度，再计算两个圆心的极角，就可以把弧对应到圆心角的一段区间上了。现在问题就变成了有一条线段，在上面覆盖一些线段，求没有被覆盖的长度。按左端点排序后扫一遍就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1005)using namespace std;int n,t;double pi=acos(-1),res,ans,maxen;double x[N],y[N],r[N];struct line&#123; double st,en;&#125;kill[N&lt;&lt;1];inline bool cmp(line a,line b)&#123; return a.st&lt;b.st;&#125;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline double sqr(double x)&#123; return x*x;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf%lf",&amp;r[i],&amp;x[i],&amp;y[i]); &#125; for (int i=1;i&lt;=n;i++)&#123; t=0; for (int j=i+1;j&lt;=n;j++)&#123; double dis=sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j])); if (dis&gt;=r[i]+r[j]) continue;// 相离 if (r[i]&gt;r[j]&amp;&amp;dis+r[j]&lt;=r[i]) continue;//a 包含 b if (r[i]&lt;r[j]&amp;&amp;dis+r[i]&lt;=r[j])&#123;//b 包含 a kill[++t]=(line)&#123;0,2*pi&#125;; break; &#125; double alpha=(sqr(r[i])+sqr(dis)-sqr(r[j]))/(2*dis*r[i]); double beta=atan2(y[j]-y[i],x[j]-x[i]); alpha=acos(alpha); //printf("emm %.3lf %.3lf\n",alpha,beta); double l=beta-alpha,r=beta+alpha; if (l&lt;0) l+=2*pi; if (r&lt;0) r+=2*pi; if (l&gt;r) kill[++t]=(line)&#123;0,r&#125;,kill[++t]=(line)&#123;l,2*pi&#125;; else kill[++t]=(line)&#123;l,r&#125;; &#125; sort(kill+1,kill+t+1,cmp); //for (int j=1;j&lt;=t;j++) printf("kill %.3lf %.3lf\n",kill[j].st,kill[j].en); if (t==0)&#123; ans+=r[i]*2*pi; continue; &#125; kill[++t].st=2*pi; maxen=0; res=kill[1].st; for (int j=1;j&lt;t;j++)&#123; maxen=max(maxen,kill[j].en); if (maxen&lt;kill[j+1].st) res+=kill[j+1].st-maxen; &#125; ans+=res*r[i]; &#125; printf("%.3lf",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1027] [JSOI2007] 合金]]></title>
    <url>%2F2019%2F02%2F26%2FBZOJ-1027-JSOI2007-%E5%90%88%E9%87%91%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1027 做法先把题意理解清楚，然后手算一下样例。可以发现每个$(x,y,z)$的原材料可以看做二维平面上的一个点$(x,y)$，因为第三维与前两维的和是定制，所以可以省略。但是第三维也并不是完全没用，有了第三维的限制，两个点组合能够表示的点就在这两个点连结所形成的线段上。根据上面的结论，那么显然多个点能表示的点就在这些点围成的凸包内。所以我们相当于从$n$个点中选出尽量少的点，使得这些点围成的凸包能够包括所有后面的m个点。由于数据范围很小，我们枚举$n$个点中的两个点$i$和$j$，如果$m$个点均在线段$ij$的逆时针侧，我们就让$i$向$j$连边，这样我们只要在最后得到图上跑一边floyd求最小环就行了。判断是否在逆时针侧的话用叉积。还要注意特判一下点恰好在这条线段上的情况，可以用点积判断夹角实现。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define LL long long#define N (150005)using namespace std;int n,maxans;LL f[N],tot;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;struct node&#123; int a,b; inline bool operator &lt; (const node &amp;t) const&#123; return a&lt;t.a; &#125; &#125;a[N];priority_queue&lt;node&gt; H;inline bool cmp(node a,node b)&#123; return a.b==b.b?a.a&lt;b.a:a.b&lt;b.b;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i].a),read(a[i].b); &#125; sort(a+1,a+n+1,cmp); for (int i=1;i&lt;=n;i++)&#123; if (tot+a[i].a&lt;=a[i].b) H.push(a[i]),tot+=a[i].a; else&#123; if (!H.empty()&amp;&amp;tot-H.top().a+a[i].a&lt;=a[i].b&amp;&amp;H.top().a&gt;a[i].a)&#123; tot-=H.top().a-a[i].a; H.pop(); H.push(a[i]); &#125; &#125; &#125; printf("%d",H.size()); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1014] [JSOI2008]火星人prefix]]></title>
    <url>%2F2019%2F02%2F25%2FBZOJ-1014-JSOI2008-%E7%81%AB%E6%98%9F%E4%BA%BAprefix%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1014 做法一眼看过去，这不是$SAM$模板题吗。再一眼，什么，还有插入和修改，那好吧，换个做法。$LCQ$和我们熟知的$LCP$本质上是一样的，有一个经典做法就是二分+哈希。所以我们可以用一棵平衡树来维护整个序列的哈希值。具体做法：以在序列中的位置作为关键字构建平衡树平衡树的每个节点维护他子树的哈希值，实际上就是序列一段的哈希值。令右子树的$size$为$R$$hash[u]=hash[lson[u]]base^{R+1}+data[u]base^R+hash[rson[u]]$这样当我们想要查询一段区间的哈希值时只要把整段区间从平衡树里拿出来就好了。插入和修改用平衡树可以实现。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,base=31,len,cnt,root,x,y;unsigned int mi[N];char c[N],op[5],a[5];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;struct node&#123; unsigned int hash; int ls,rs,val,size,heap;&#125;T[N]; struct two&#123; int ls,rs;&#125;;inline void update(int u)&#123; int R=T[T[u].rs].size; T[u].hash=T[T[u].ls].hash*mi[R+1]+T[u].val*mi[R]+T[T[u].rs].hash; T[u].size=T[T[u].ls].size+T[T[u].rs].size+1;&#125;inline two split(int u,int k)&#123; two ret=&#123;0,0&#125;; if (!u) return ret; int lsize=T[T[u].ls].size+1; if (k&gt;=lsize)&#123; ret=split(T[u].rs,k-lsize); T[u].rs=ret.ls; ret.ls=u; &#125; else&#123; ret=split(T[u].ls,k); T[u].ls=ret.rs; ret.rs=u; &#125; update(u); return ret;&#125;inline int merge(int x,int y)&#123; if (!x) return y; if (!y) return x; if (T[x].heap&lt;T[y].heap)&#123; T[x].rs=merge(T[x].rs,y); update(x); return x; &#125; else&#123; T[y].ls=merge(x,T[y].ls); update(y); return y; &#125;&#125;inline void insert(int pos,int x)&#123; cnt++; T[cnt].size=1,T[cnt].val=x,T[cnt].hash=x; T[cnt].heap=rand(); two p1=split(root,pos); root=merge(p1.ls,merge(cnt,p1.rs));&#125;inline int query(int l,int r)&#123; //printf("%d %d ",l,r); two p1=split(root,r); two p2=split(p1.ls,l-1); unsigned int ret=T[p2.rs].hash; root=merge(merge(p2.ls,p2.rs),p1.rs); //printf("%u\n",ret); return ret;&#125;inline void bl(int u)&#123;// printf("%d %d %u\n",u,T[u].size,T[u].hash); if (T[u].ls) bl(T[u].ls); if (T[u].rs) bl(T[u].rs);&#125; int main()&#123; mi[0]=1; for (int i=1;i&lt;=100000;i++) mi[i]=mi[i-1]*base; scanf("%s",c+1); len=strlen(c+1); for (int i=1;i&lt;=len;i++)&#123; insert(i-1,c[i]-'a'+1); &#125; bl(root); read(n); while (n--)&#123; scanf("%s",op); if (op[0]=='Q')&#123; read(x),read(y); if (x&lt;y) swap(x,y); int l=1,r=cnt-x+1,ans=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (query(x,x+mid-1)==query(y,y+mid-1)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); &#125; if (op[0]=='R')&#123; read(x); scanf("%s",a); two p1=split(root,x-1); two p2=split(p1.rs,1); T[p2.ls].hash=T[p2.ls].val=a[0]-'a'+1; root=merge(p1.ls,merge(p2.ls,p2.rs)); &#125; if (op[0]=='I')&#123; read(x); scanf("%s",a); insert(x,a[0]-'a'+1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1007] [HNOI2008] 水平可见直线]]></title>
    <url>%2F2019%2F02%2F25%2FBZOJ-1007-HNOI2008-%E6%B0%B4%E5%B9%B3%E5%8F%AF%E8%A7%81%E7%9B%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1007 做法我们每加入一条直线，那么它下方的直线就看不到了。所以最后能看到的形状一定是一个下凸壳。所以我们先按斜率从小到大排序。用一个单调栈维护每一段凸壳是哪一条直线，以及这一段凸壳的左端点。每次加入一条新的直线，如果这条直线与目前栈顶的这条直线的交点，小于这段凸壳的左端点，那么栈顶这条直线一定不在凸壳上了，从栈中弹出。最后加入我这条直线就行了。至于精度问题，博主在算交点的时候，用两个整数来表示这个交点的分子和分母，存的时候也存两个整数，就能解决了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,top,t;int st[N],dk[N],db[N],ans[N]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;struct node&#123; int k,b,id;&#125;a[N];inline bool cmp(node a,node b)&#123; return a.k==b.k?a.b&gt;b.b:a.k&lt;b.k;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i].k),read(a[i].b); a[i].id=i; &#125; sort(a+1,a+n+1,cmp); st[++top]=1; for (int i=2;i&lt;=n;i++)&#123; if (a[i].k==a[i-1].k) continue; int tk=a[i].k-a[st[top]].k,tb=a[st[top]].b-a[i].b; //printf("%d %d\n",tk,tb); while (top&amp;&amp;1ll*tb*dk[top]&lt;=1ll*db[top]*tk&amp;&amp;st[top]!=1)&#123; top--; tk=a[i].k-a[st[top]].k,tb=a[st[top]].b-a[i].b; &#125; st[++top]=i; db[top]=tb; dk[top]=tk; &#125; while (top)&#123; ans[++t]=a[st[top]].id; top--; &#125; sort(ans+1,ans+t+1); for (int i=1;i&lt;=t;i++) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1145] [CTSC2008] 图腾totem]]></title>
    <url>%2F2019%2F02%2F25%2FBZOJ-1145-CTSC2008-%E5%9B%BE%E8%85%BEtotem%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1145 做法我们用一个四个数字来表示这个四元组的相对大小关系。比如说闪电图腾我们就定义为$1342$山峰图腾表示为$1243$或$1432$现在我们要求的就是$f(1342)-f(1243)-f(1432)$以下式子中的$X$表示任意 \begin{aligned} f(1324)-f(1432)-f(1243)&=(f(1X2X)-f(1423))-(f(14X)-f(1423))-(f(12X)-f(1234)) \\ &=f(1X2X)-f(14X)-f(12X)+f(1234) \\ &=f(1X2X)-(f(1X)-f(13X))+f(1234) \\ &=f(1X2X)-f(1X)+f(13X)+f(1234) \end{aligned}我们先用树状数组求出两个数组$l[i],r[i]$，分别表示$i$这个点左边比我小的点的个数，右边比我小的点的个数。 对于求$f(1X)$这个非常方便，对于每个点，贡献为$\binom{n-i-r[i]}{3}$ 对于求$f(1234)$我们在$3$处统计答案，对于每个点，贡献为$(n-i-r[i])*\binom{l[i]}{2}$ 对于$f(1X2X)$我们在$2$处统计答案。可以发现每个点的贡献就是$f(132)*(n-i-r[i])$现在我们考虑求$f(132)$,$f(132)=(f(132)+f(312)+f(123)+f(213))-(f(312)+f(123)+f(213))$都是在最后一个位置上统计答案。对于前一个括号，实际上就是从前面找两个数，有一个小于我就行了，答案为$\binom{l[i]}{2}+l[i]*(i-1-l[i])$而后面一个括号，第二个数小于我，第一个数随便，也就是$\sum\limits_{j=1}^{i-1}(j-1)*[a[j]&lt;a[i]]$，树状数组维护就好了。 对于$f(13XX)$在$3$处统计答案。同样可以发现答案等同于$f(132)*(n-i-r[i])$与上面不同的是，这次统计答案的位置在$3$.$f(132)=(f(132)+f(312)+f(321))-(f(312)+f(321))$都是在$3$所在位置统计答案。对于前一个括号，发现$2$一定在$3$右侧，而$1$的位置则随意，那么答案就是$\sum\limits_{j=i+1}^{n}(a[j]-1)*[a[j]&lt;a[i]]$，同样可以树状数组维护。而后面一个括号，实际上就是$f(3XX)=\binom{r[i]}{2}$ 以上就是每种情况下每个点的答案，我们对于每种情况扫一下所有点就好了。复杂度$O(n*logn)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (200005)using namespace std;int n; int l[N],r[N],a[N],T[N];const int P=16777216;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline void add(int x,int y)&#123; for (int i=x;i&lt;=n;i+=i&amp;-i) T[i]=Inc(T[i],y);&#125; inline int query(int x)&#123; int ret=0; for (int i=x;i;i-=i&amp;-i) ret=Inc(ret,T[i]); return ret;&#125;inline int work1()&#123; //1*2* int ans=0,tt=0; memset(T,0,sizeof(T)); for (int i=1;i&lt;=n;i++)&#123; tt=Inc(1ll*l[i]*(l[i]-1)/2%P,1ll*l[i]*(i-1-l[i])%P); tt=Inc(tt,P-query(a[i])); ans=Inc(ans,1ll*tt*(n-i-r[i])%P); add(a[i],i-1); &#125; return ans;&#125;inline int work2()&#123; //1*** int ans=0; memset(T,0,sizeof(T)); for (int i=1;i&lt;=n;i++)&#123; int tt=n-i-r[i]; if (tt&gt;=3)&#123; ans=Inc(ans,(1ll*tt*(tt-1)*(tt-2)/6)%P); &#125; &#125; return ans;&#125;inline int work3()&#123; //13** int ans=0,tt=0; memset(T,0,sizeof(T)); for (int i=n;i&gt;=1;i--)&#123; int tt=query(a[i]); tt=Inc(tt,P-1ll*r[i]*(r[i]-1)/2%P); ans=Inc(ans,1ll*tt*(n-r[i]-i)%P); add(a[i],a[i]-1); &#125; return ans;&#125;inline int work4()&#123; //1234 int ans=0; memset(T,0,sizeof(T)); for (int i=1;i&lt;=n;i++)&#123; ans=Inc(ans,1ll*query(a[i])*(n-i-r[i])%P); add(a[i],l[i]); &#125; return ans;&#125; int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i]); l[i]=query(a[i]); r[i]=a[i]-1-l[i]; add(a[i],1); &#125; //printf("%d %d %d %d\n",work1(),work2(),work3(),work4()); printf("%d",(work1()-work2()+work3()+work4()+P)%P); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3469] [POI2008]BLO-Blockade]]></title>
    <url>%2F2019%2F02%2F23%2FLuogu-3469-POI2008-BLO-Blockade%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3469 题目大意给定一张$n$个点$m$条边的联通无向图，问删除每个点后有多少点不连通。$n\le 10^5$，$m\le 5*10^5$ 做法如果我们能够快速知道每个点被删除后，剩下的每个联通块的大小就可以算出答案了。具体做法：对每个节点记录一个$now$，一个$ans$，表示这个节点当前联通块大小的和，找到一个新的联通块后$ans+=now*size,now+=size$那么我们就用$tarjan$求割点，每当一个点作为割点的时候统计答案。用$size_i$表示$i$号点目前所在联通块的大小。$now_i,ans_i$表示上述做法中的$now,ans$在$tarjan$求割点的时候，如果发现$low[v]&gt;=dfn[u]$，说明$v$所在的联通块在割掉$u$这个点之后是一个独立的联通块，那么$ans[u]+=now[u]*size[v],now[u]+=size[v]$。但是别忘了最后还要加上最后一个联通块，这个联通块是在$tarjan$我之前遍历的那个联通块。所以$ans[u]+=now[u]*(n-now[u]-1)$还有就是我这个点被删掉了，所以我不能走到其他的任意点$ans[u]+=n-1$由于点对是无序点对，$ans[u]*=2$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)#define M (500005)using namespace std;int n,m,tot,cnt,x,y;int head[N],nxt[M&lt;&lt;1],son[M&lt;&lt;1],now[N],size[N],dfn[N],low[N];LL ans[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; son[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;inline void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; size[u]=1; for (int p=head[u];p;p=nxt[p])&#123; int v=son[p]; if (!dfn[v])&#123; tarjan(v); size[u]+=size[v]; low[u]=min(low[u],low[v]); if (low[v]&gt;=dfn[u])&#123; ans[u]+=1ll*now[u]*size[v]; now[u]+=size[v]; &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=m;i++)&#123; read(x),read(y); add(x,y),add(y,x); &#125; tarjan(1); for (int i=1;i&lt;=n;i++) ans[i]+=1ll*now[i]*(n-now[i]-1); for (int i=1;i&lt;=n;i++) ans[i]=(ans[i]+(n-1))*2; for (int i=1;i&lt;=n;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
        <tag>双联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prufer序列学习笔记]]></title>
    <url>%2F2019%2F02%2F22%2Fprufer%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介$prufer$序列，是讲一棵树唯一转化为一个序列，在解决无根树的计数问题时十分有用。 无根树转$prufer$序列我们定义一棵树的叶子为这棵树上度数为$1$的点。每次找到编号最小的叶子节点，讲目前唯一与它相连的点的编号加入$prufer$序列，并删除这个叶子节点。当最后还剩两个点的时候停止。比如下图的$prufer$序列为$\{3,2,2,1,1\}$。实现的话拿个$set$维护一下叶子结点就好了。 $prufer$序列转无根树先有一个点集V，表示目前可能为叶子的集合，初始时等于{1..n}。从前往后扫$prufer$序列，设$prufer$序列上这一位为$u$，找到$V$中没在之后的$prufer$序列中出现过，编号最小的节点$v$，将$u,v$连上一条边，并把$v$从$V$中删除。直至最后$V$中剩下两个节点，将这两个节点间连边后停止。实现的话同样是一个set可以搞定。 性质通过上面这两种转化方式，显然一棵无根树只会与恰好一个$prufer$序列对应.最重要的性质就是每个点在$prufer$序列中恰好出现度数-1次。 带标号无根树计数给你$n$个点，让你求出$n$个点的无根树的数量为多少。BZOJ 1430根据上面的两条性质，题目转化为在一个长度为$n-2$的序列中填上$[1..n]$的方案数，显然为$n^{n-2}$例题中再乘以一个$(n-1)!$阶乘就好了。 带标号无根树计数推广推广1给你$n$个点，并给定每个点的度数$d_i$，求出这$n$个点可以构成无根树的数量。题意可以转化为，在长度为$n-2$的数列中，填上$[1..n]$，且$i$出现$d_i-1$次。那么答案应该为 \frac{(n-2)!}{\prod\limits_{i=1}^{n}(d_i-1)!}推广2给你$n$个点，$k$个点的度数确定，剩下点的度数随意，求出这$n$个点可以构成的无根树的数量。BZOJ 1005假设prufer序列还有$res$个位置未确定$res=(n-2)-\sum\limits_{i=1}^{k}(d_i-1)$总方案为 \frac{(n-2)!}{res!*\prod\limits_{i=1}^{k}(d_i-1)!}*(n-k)^{res}例题只需要在这个基础上加一个高精度即可。 带标号有根树计数只需要给无根树选一个根就好了 n^{n-2}*n结语博主水平有限，目前只会不带标号的计数，带标号的有机会再更。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 2671] Calc]]></title>
    <url>%2F2019%2F02%2F22%2FBZOJ-2671-Calc%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 2671 题目大意给出n，求出满足以下两个条件的数对(a,b)的数量$1. 1\le a&lt;b \le n$ $2. (a+b)|(a*b)$ 做法对于数对$(a,b)$，令$g=gcd(a,b)$，再令$p*g=a,q*g=b$那么有$(p*g+q*g)|(p*g*q*g)$两边同时约掉一个g，$(p+q)|(p*q+g)$由于$p,q$互质，所以$(p+q)$与$(p*q)$也一定互质，这个结论应该还是比较显然的。所以还要满足整除关系的话，$g$一定是$(p+q)$的倍数，我们令$g=k*(p+q)$别忘了我们还有第一个限制条件，我们将b代入。$b=g*q=k*(p+q)*q\le n$显然$q\le \sqrt n$令$m=\sqrt{n}$枚举$q$，可以得到 ans=\sum_{q=1}^{m}\sum_{p=q+1}^{m}[gcd(p,q)==1]*\lfloor\frac{n}{y(x+y)}\rfloor看到这个$[gcd(x,y)==1]$，想到莫比乌斯反演 ans=\sum_{q=1}^{m}\sum_{p=q+1}^{m}\lfloor\frac{n}{y(x+y)}\rfloor*\sum_{d|gcd(x,y)}\mu(d)还是老套路，改为枚举$d$和倍数 ans=\sum_{d=1}^{m}\mu(d)\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{j=1}^{i-1}\lfloor\frac{n}{d*d(i+j)*i}\rfloor再进行一步简单的变形，改为枚举$i+j$和$i$ ans=\sum_{d=1}^{m}\mu(d)\sum_{i=2}^{2*\lfloor\frac{m}{d}\rfloor-1}\sum_{j=\frac{i}{2}+1}^{i-1}\lfloor\frac{n}{d*d*i*j}\rfloor我们先枚举$d$，再枚举$i$，根据调和级数，这一步的复杂度是$O(m*logm)$的，有了$d$和$i$了之后，再对$j$整除分块，复杂度大概是$O(m^{\frac{3}{2}}*logm)$，也就是$O(n^{\frac{3}{2}}*log\sqrt n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;bool nprime[N];int pri,r;LL ans;int prime[N],mu[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int n,m;int main()&#123; read(n); m=sqrt(n); mu[1]=1; for (int i=2;i&lt;=m;i++)&#123; if (!nprime[i])&#123; prime[++pri]=i; mu[i]=-1; &#125; for (int j=1;j&lt;=pri&amp;&amp;i*prime[j]&lt;=m;j++)&#123; nprime[i*prime[j]]=1; if (i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125; for (int d=1;d&lt;=m;d++)&#123; if (mu[d]==0) continue; for (int i=2;i&lt;=2*(m/d)-1;i++)&#123; int t=n/d/d/i; if (t==0) break; //for (int j=i/2+1;j&lt;i;j++) ans+=mu[d]*(t/j); for (int j=i/2+1;j&lt;i;j=r+1)&#123; if (t/j==0) break; r=min(i-1,t/(t/j)); ans+=(r-j+1)*(t/j)*mu[d]; &#125; &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF 662C] Binary Table]]></title>
    <url>%2F2019%2F02%2F22%2FCF-662C-Binary-Table%2F</url>
    <content type="text"><![CDATA[题目链接CF 662C 做法听说是一道tourist在考场上都没切的题，不过是真的想不到啊。。。暴力还是比较好想的，我们枚举翻转哪些行，在队每一列贪心就行了。先预处理$g(i)$表示状态$i$的答案显然$g(i)=Min(popcount(i),n-popcount(i))$复杂度$O(2^n*m)$发现暴力的瓶颈在于每次枚举状态之后都要$O(m)$枚举一遍。考虑能不能一起计算。用$f(i)$表示矩阵初始状态时，状态为$i$的列有多少个。用$F(i)$表示行翻转状态为i的答案。那么有 F(s)=\sum_{i=0}^{2^n-1}f(i)*g(i\oplus s)由于$s\oplus i\oplus i=s$ F(s)=\sum_{i\oplus j=s}f(i)*g(j)就得到了一个标准的$FWT$卷积形式，用异或卷积卷一下就ok了。复杂度$O(2^n*n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,m,lim,invL,ans;int g[1&lt;&lt;20],popc[1&lt;&lt;20],f[1&lt;&lt;20],a[25][N];const int P=998244353;char c[N]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline void FWT(int *f,int g)&#123; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; for (int k=j;k&lt;i+j;k++)&#123; int tt=f[k+i]; f[k+i]=Inc(f[k],P-tt); f[k]=Inc(f[k],tt); &#125; &#125; &#125; if (g==-1)&#123; for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*invL%P; &#125;&#125;int main()&#123; read(n),read(m); ans=n*m; lim=1&lt;&lt;n; invL=ksm(lim,P-2); for (int i=1;i&lt;=n;i++)&#123; scanf("%s",c+1); for (int j=1;j&lt;=m;j++) a[i][j]=c[j]-'0'; &#125; for (int i=0;i&lt;lim;i++)&#123; popc[i]=popc[i&gt;&gt;1]+(i&amp;1); g[i]=min(popc[i],n-popc[i]); &#125; for (int i=1;i&lt;=m;i++)&#123; int tt=0; for (int j=1;j&lt;=n;j++)&#123; tt+=a[j][i]*(1&lt;&lt;j-1); &#125; f[tt]++; &#125; FWT(f,1),FWT(g,1); for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*g[i]%P; FWT(f,-1); for (int i=0;i&lt;lim;i++)&#123; ans=min(ans,f[i]); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>CF</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 4491] [HAOI2018]染色]]></title>
    <url>%2F2019%2F02%2F20%2FLuogu-4491-HAOI2018-%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 4491 做法做反演题已经做到看到恰好就非常敏感了。令$g_i$表示出现恰好$S$次的颜色至少$i$种的方案数，$f_i$表示出现恰好$S$次的颜色恰好$i$种的方案数。先计算$g_i$,我们就钦定这些颜色是哪些颜色，哪些位置，其他随便放就行了。 g_i=\binom{m}{i}*\binom{n}{i*S}*\frac{(i*S)!}{(S!)^{i}}*(n-i*S)^{m-i}而显然 g_i=\sum_{j=i}^{m}\binom{j}{i}*f_j二项式反演就可以得到 f_i=\sum_{j=i}^{m}(-1)^{j-i}*\binom{j}{i}*g_j而现在我们要求的就是$f_{0..m}$，如果直接算的话复杂度为$m^2$。可以把$f$数组看成一个多项式，由$g$这个多项式乘上另一个多项式得到。考虑如何构造多项式。先把枚举$j$改为枚举$j-i$，从0开始比较方便多项式乘法。组合数也不好处理，用阶乘暴力展开，那么原式可以化为 f_i=\sum_{j=0}^{m-i}(-1)^{j}*\frac{(i+j)!}{(i!)*(j!)}*g_{i+j}发现$(i+j)!$和$g_{i+j}$都与$i+j$有关，那么把它们合并，再转个头即$g’_i=g_{m-i}*(m-i)!$而$\frac{1}{i!}$至于i有关，那么我们算出f后再乘上就行了，暂时不用管。经过上面两步的变换后，式子变成了这样 f_i=\sum_{j=0}^{m-i}(-1)j*\frac{1}{j!}*g'_{m-i-j}发现还是对不上，我们把$f$也转个头，即$f’_{m-i}=f_i$，那么 f'_{m-i}=\sum_{j=0}^{m-i}(-1)j*\frac{1}{j!}*g'_{m-i-j}就是一个标准的卷积形式了。我们$NTT$做完后，把上面那些操作都做逆操作就可以了。最后注意一下$1004535809$这个模数的原根也是$3$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (10000005)using namespace std;int n,m,s,ans,d,size=1e7,lim,G=3;int f[N],jc[N],inv[N],A[N],w[N],g[N],R[N];const int P=1004535809; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int C(int a,int b)&#123; return 1ll*jc[a]*inv[b]%P*inv[a-b]%P;&#125;inline void NTT(int *f,int G)&#123; for (int i=0;i&lt;lim;i++)&#123; if (i&gt;R[i]) swap(f[i],f[R[i]]); &#125; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; int w0=ksm(G,(P-1)/(i&lt;&lt;1)); for (int j=0;j&lt;lim;j+=i&lt;&lt;1)&#123; int w=1; for (int k=j;k&lt;j+i;k++)&#123; int t=1ll*f[k+i]*w%P; f[k+i]=Inc(f[k]-t,P); f[k]=Inc(f[k],t); w=1ll*w*w0%P; &#125; &#125; &#125; if (G!=3)&#123; int invl=ksm(lim,P-2); for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*invl%P; &#125;&#125;int main()&#123; read(n),read(m),read(s); d=1; jc[0]=1; for (int i=1;i&lt;=size;i++) jc[i]=1ll*jc[i-1]*i%P; A[0]=A[1]=1; for (int i=2;i&lt;=size;i++) A[i]=Inc(-1ll*P/i*A[P%i]%P,P); inv[0]=1; for (int i=1;i&lt;=size;i++) inv[i]=1ll*inv[i-1]*A[i]%P; for (int i=0;i*s&lt;=n&amp;&amp;i&lt;=m;i++)&#123; g[i]=1ll*C(m,i)*C(n,i*s)%P*jc[i*s]%P*ksm(m-i,n-i*s)%P*ksm(ksm(jc[s],i),P-2)%P; g[i]=1ll*g[i]*jc[i]%P; &#125; for (int i=0;i&lt;=m/2;i++) swap(g[i],g[m-i]); for (int i=0;i&lt;=m;i++)&#123; if (i&amp;1) f[i]=P-inv[i]; else f[i]=inv[i]; &#125; for (lim=1;lim&lt;2*(m+2);lim&lt;&lt;=1); for (int i=0;i&lt;lim;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*lim&gt;&gt;1); NTT(f,G),NTT(g,G); for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*g[i]%P; NTT(f,ksm(G,P-2)); for (int i=0;i&lt;=m;i++)&#123; read(w[i]); ans=Inc(ans,1ll*w[i]*f[m-i]%P*inv[i]%P); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3700] [CQOI2017]小Q的表格]]></title>
    <url>%2F2019%2F02%2F10%2FLuogu-3700-CQOI2017-%E5%B0%8FQ%E7%9A%84%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3700 做法首先打表找规律可以得知令$d=gcd(x,y)$ f_{x,y}=f_{d,d}*\frac{x*y}{d^2}那么ans就可以换一种表现形式 ans=\sum_{i=1}^{k}\sum_{j=1}^{k}f_{i,j}\\ ans=\sum_{i=1}^{k}\sum_{j=1}^{k}f_{d,d}*\frac{x*y}{d^2}改变枚举顺序，先枚举d ans=\sum_{d=1}^{k}*f_{d,d}*\sum_{i=1}^{\lfloor\frac{k}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{k}{d}\rfloor}i*j*[gcd(i,j)=1]我们令 A(x)=\sum_{i=1}^{x}\sum_{j=1}^{x}i*j*[gcd(i,j)=1]考虑$A(x)$比$A(x-1)$多了什么多的这部分为 \sum_{i=1}^{x}i*x*[gcd(i,x)==1]*2-x*x*[gcd(x,x)=1]显然$A(1)=1$所以我们这里只需要考虑$x&gt;1$的情况，后面减的那项为0而由于$i&lt;x$且$gcd(i,x)=1$，所以$gcd(i,x-i)=1$也成立。这也就意味着所有与$x$互质且小于$x$的数都可以两两组成和为$x$的组。所以 A(x)=A(x-1)+\phi(x)*x^2也就是说 A(x)=\sum_{i=1}^{x}\phi(i)*i^2我们再回到开头$ans$的式子 ans=\sum_{d=1}^{k}*f_{d,d}*A(\lfloor\frac{k}{d}\rfloor)$\lfloor\frac{k}{d}\rfloor$只有$\sqrt{k}=2000$种取值，我们数论分块计算。而对于$f$就变成了一个单点修改，区间求值的问题。再注意到实际上修改只用进行$10^4$次，而查询需要$2000*10^4$次。我们就将序列分块，维护块的前缀和，再维护每个块中的前缀和，就可以做到$O(\sqrt{n})$修改，$O(1)$查询了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (4000005)using namespace std;int m,n,pri,ans,x,y,k,g,unit,tot,r;LL d;int A[N],prime[N],phi[N],f[N],be[N],sum[2005],pr[2005][2005];bool nprime[N];const int P=1000000007; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int gcd(int a,int b)&#123; while (a%b!=0)&#123; int tmp=b; b=a%b; a=tmp; &#125; return b;&#125;void change(int x,int d)&#123; d=Inc(d,P); for (int i=be[x];i&lt;=tot;i++) sum[i]=Inc(sum[i],d); for (int i=x-(be[x]-1)*unit;i&lt;=unit;i++) pr[be[x]][i]=Inc(pr[be[x]][i],d);&#125;int query(int x)&#123; return Inc(sum[be[x]-1],pr[be[x]][x-(be[x]-1)*unit]);&#125;signed main()&#123; read(m),read(n); phi[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (!nprime[i]) prime[++pri]=i,phi[i]=i-1; for (int j=1;j&lt;=pri&amp;&amp;i*prime[j]&lt;=n;j++)&#123; nprime[i*prime[j]]=1; if (i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125; for (int i=1;i&lt;=n;i++) A[i]=Inc(A[i-1],1ll*phi[i]*i%P*i%P); unit=sqrt(n); for (int i=1;i&lt;=n;i++)&#123; be[i]=(i-1)/unit+1; &#125; tot=be[n]; for (int i=1;i&lt;=n;i++)&#123; f[i]=1ll*i*i%P; if (be[i]!=be[i-1]) sum[be[i]]=sum[be[i-1]]; sum[be[i]]=Inc(sum[be[i]],f[i]); int num=i-(be[i]-1)*unit; pr[be[i]][num]=Inc(pr[be[i]][num-1],f[i]); &#125; for (int i=1;i&lt;=m;i++)&#123; read(x),read(y),read(d),read(k); g=gcd(x,y); d=d/(x/g)/(y/g)%P; change(g,d-f[g]); f[g]=d; ans=0; for (int l=1;l&lt;=k;l=r+1)&#123; r=k/(k/l); ans=Inc(ans,1ll*Inc(query(r)-query(l-1),P)*A[k/l]%P); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 6374]「SDWC2018 Day1」网格]]></title>
    <url>%2F2019%2F02%2F09%2FLOJ-6374-%E3%80%8CSDWC2018-Day1%E3%80%8D%E7%BD%91%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 6374 做法先考虑$k=0$的部分分。发现$x,y$这两维有一定的独立性，先分开考虑。我们以$calc(x,y,z)$表示跳$z$步，每步不超过$y$格，总共跳了$x$格的方案数，直接dp复杂度为$O(10^6)$不能接受，考虑容斥。先以$g_i$表示至少有i步超过了$y$格的方案数。我们从$z$步中选择$i$步先跳$y+1$格，剩下的话插板法解决。 g_i=\binom{z}{i}*\binom{x-i*(y+1)+z-1}{z-1}用$f_i$表示恰好有$i$步超过了$y$格的方案数，二项式反演即可。$calc(x,y,z)$所求答案即为$f_0$ calc(x,y,z)=\sum\limits_{i=0}^{z}*(-1)^i*g_i但是两维并不完全独立，因为题目规定了不能两维上同时在一步上跳$0$格。$g_i$表示至多走了$i$步的方案(两维上都跳0格不算一步)。$g_i=calc(tx,mx,z)*calc(ty,my,z)$$f_i$表示恰好走了$i$步的方案。再次二项式反演 f_i=\sum_{j=0}^{i}*(-1)^{i-j}*\binom{i}{j}*g_j这样我们就解决了$k=0$的部分分再考虑有k的限制。温馨提示：先把k去重$g_i$表示至少有$i$步违反限制的方案数先$dp$出$f_{i,j}$表示$i$步违反限制，总格数为$G*j$的方案数，$j$最大只有100，可以轻松dp出。那么计算$g_i$的时候，先枚举这$i$步总共跳了多少格，剩下的步数可以转化成一个$k=0$的问题。有了$g$后，剩下的反演就和第一步一模一样了。复杂度为$O(1000*1000*100*100)$，发现前面calc需要计算的值不多，记忆化后可以去掉一个1000，就解决了此题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1000005)using namespace std;int tx,ty,mx,my,R,G,size,k,x,ans,d;int fac[N],inv[N],A[N],f[105][105],gx[105][1005],gy[105][1005],q[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;const int P=1000000007;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int C(int a,int b)&#123; if (a&lt;0||b&lt;0||b&gt;a) return 0; return 1ll*fac[a]*inv[b]%P*inv[a-b]%P; &#125;inline int calcx(int x,int y,int z)&#123; if (gx[(tx-x)/G][z]&gt;=0) return gx[(tx-x)/G][z]; int ret=0,d=1; for (int i=0;i&lt;=z;i++)&#123; ret=Inc(ret,1ll*C(z,i)*C(x-(y+1)*i+z-1,z-1)%P*d); ret=Inc(ret,P); d=-d; &#125; gx[(tx-x)/G][z]=ret; return ret;&#125;inline int calcy(int x,int y,int z)&#123; if (gy[(ty-x)/G][z]&gt;=0) return gy[(ty-x)/G][z]; int ret=0,d=1; for (int i=0;i&lt;=z;i++)&#123; ret=Inc(ret,1ll*C(z,i)*C(x-(y+1)*i+z-1,z-1)%P*d); ret=Inc(ret,P); d=-d; &#125; gy[(ty-x)/G][z]=ret; return ret;&#125;inline void init()&#123; size=1e6; fac[0]=1; for (int i=1;i&lt;=size;i++) fac[i]=1ll*fac[i-1]*i%P; A[0]=A[1]=1; for (int i=2;i&lt;=size;i++) A[i]=Inc(1ll*-P/i*A[P%i]%P,P); inv[0]=1; for (int i=1;i&lt;=size;i++) inv[i]=1ll*inv[i-1]*A[i]%P;&#125;inline int get(int tx,int ty,int mx,int my,int R)&#123; if (tx&lt;0||ty&lt;0) return 0; int d=1,ans=0; for (int i=R;i&gt;=0;i--)&#123; ans=Inc(ans,1ll*C(R,i)*calcx(tx,mx,i)%P*calcy(ty,my,i)%P*d); ans=Inc(ans,P); d=-d; &#125; return ans;&#125; int main()&#123; read(tx),read(ty),read(mx),read(my); read(R),read(G); init(); read(k); for (int i=1;i&lt;=k;i++)&#123; read(x); q[i]=x/G; &#125; sort(q+1,q+k+1); k=unique(q+1,q+k+1)-q-1; f[0][0]=1; for (int i=1;i&lt;=100;i++)&#123; for (int j=0;j&lt;=100;j++)&#123; for (int t=1;t&lt;=k;t++)&#123; if (q[t]&lt;=j) f[i][j]=Inc(f[i][j],f[i-1][j-q[t]]); &#125; &#125; &#125; ans=0; d=1; memset(gx,-1,sizeof(gx)); memset(gy,-1,sizeof(gy)); for (int i=0;i&lt;=min(R,100);i++)&#123; int tt=0; for (int j=0;j&lt;=100;j++) tt=Inc(tt,1ll*f[i][j]*get(tx-j*G,ty-j*G,mx,my,R-i)%P); ans=Inc(ans,1ll*tt*C(R,i)%P*d); ans=Inc(ans,P); d=-d; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3349] [ZJOI2016]小星星]]></title>
    <url>%2F2019%2F02%2F09%2FLuogu-3349-ZJOI2016-%E5%B0%8F%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3349 做法发现每个树上的点要对应不同的图上的点不好处理，我们考虑求树上的点可以对应相同的点。我们以$g_i$表示树上的点可以对应相同的点，且对应的点中没出现状态$i$的方案数。那么根据容斥我们知道最后的答案即为 ans=\sum\limits_{i}*(-1)^{|i|}*g_i所以我们先枚举状态i，在用$f_{j,k}$表示做完j的子树，j这个点的对应k的方案数。转移的话先枚举自己对应哪个点，然后分别计算每个子树的贡献即可。总复杂度$O(2^n*n^3)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (25)using namespace std;int n,m,x,y,tot,s,all;int head[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],map[N][N];LL f[N][N],ans,tt; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; son[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;inline void dfs(int u,int fa)&#123; for (register int p=head[u];p;p=nxt[p])&#123; if (son[p]!=fa) dfs(son[p],u); &#125; for (register int i=1;i&lt;=n;i++)&#123; if ((1&lt;&lt;i-1)&amp;(all-s)) f[u][i]=1; else f[u][i]=0; for (register int p=head[u];p;p=nxt[p])&#123; int v=son[p]; if (v!=fa)&#123; tt=0; for (register int j=1;j&lt;=n;j++)&#123; if (map[i][j]) tt+=f[v][j]; &#125; f[u][i]*=tt; &#125; &#125; &#125;&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=m;i++)&#123; read(x),read(y); map[x][y]=map[y][x]=1; &#125; for (int i=1;i&lt;n;i++)&#123; read(x),read(y); add(x,y),add(y,x); &#125; all=(1&lt;&lt;n)-1; for (s=0;s&lt;=all;s++)&#123; dfs(1,0); int k=__builtin_popcount(s); if (k&amp;1)&#123; for (int i=1;i&lt;=n;i++) ans-=f[1][i]; &#125; else for (int i=1;i&lt;=n;i++) ans+=f[1][i]; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树形dp</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 2026] [JLOI2016]成绩比较]]></title>
    <url>%2F2019%2F01%2F26%2FLOJ-2026-JLOI2016-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 2026 做法非常自然的就想到dp，以$f_{i,j}$表示前$i$门课，目前碾压了$j$人的方案数。枚举我这门课的分数$a$，前$i-1$门中有$k$个人被碾压。$u_i$表示这门课的最高分，$r_i$表示B神这门课的排名。转移如下 f_{i,j}=\sum\limits_{k=j}^{n-1}f_{i-1,k}*\binom{k}{j}*\binom{n-1-k}{n-r_i-j}\sum\limits_{a=1}^{u_i}*(x-a)^{r_i-1}*a^{n-r_i}实际上就是强行钦定j个人的分数仍然小于等于我，k-j个人的分数都大于我。分数小于等于我的实际人数为$n-r_i$个，已经钦定了$j$个，所以还剩$n-r_i-j$个在除了k个被钦定过的人之外选。后面这个求和就是计算有不同分数的方案数。以上做法可以获得40分。主要原始是在$u_i$大的时候枚举的复杂度无法接受。发现后面一个求和显然是个关于$u_i$的n次函数(由于有求和，所以再加一次)，我们用拉格朗日插值就可以在$O(n)$的时间复杂度内计算出。预处理快速幂，时间复杂度$O(n^4)$LOJ太快了，不预处理快速幂都能过 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (105)using namespace std;int n,m,op;int f[N][N],a[N],rnk[N],C[N][N],y[N],w[N],mi[N][N]; const int P=1000000007;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125; int main()&#123; read(n),read(m),read(op); for (int i=1;i&lt;=m;i++) read(a[i]); for (int i=1;i&lt;=m;i++) read(rnk[i]); C[0][0]=1; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) C[i][j]=Inc(C[i-1][j-1],C[i-1][j]); C[i][0]=1; &#125; f[0][n-1]=1; for (int i=0;i&lt;=n;i++)&#123; for (int j=0;j&lt;=n;j++) mi[i][j]=ksm(i,j); &#125; for (int i=1;i&lt;=m;i++)&#123; for (int j=0;j&lt;=n-rnk[i];j++)&#123; for (int x=0;x&lt;=n;x++)&#123; y[x]=0; for (int num=1;num&lt;=x;num++) y[x]=Inc(y[x],1ll*mi[x-num][rnk[i]-1]*mi[num][n-rnk[i]]%P); &#125; for (int x=0;x&lt;=n;x++)&#123; w[x]=1; for (int l=0;l&lt;=n;l++)&#123; if (x!=l) w[x]=1ll*w[x]*(x-l+P)%P; &#125; w[x]=ksm(w[x],P-2); &#125; int l=1; for (int x=0;x&lt;=n;x++) l=1ll*l*(a[i]-x+P)%P; int t=0; if (a[i]&lt;=n)&#123; t=y[a[i]]; &#125; else&#123; for (int x=0;x&lt;=n;x++)&#123; t=Inc(t,1ll*y[x]*w[x]%P*l%P*ksm(a[i]-x,P-2)%P); &#125; &#125; for (int k=j;k&lt;n;k++)&#123; f[i][j]=Inc(f[i][j],1ll*f[i-1][k]*C[k][j]%P*t%P*C[n-1-k][n-rnk[i]-j]%P); &#125; //printf("%d %d %d\n",i,j,f[i][j]); &#125; &#125; printf("%d",f[m][op]); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 4593] [TJOI2018]教科书般的亵渎]]></title>
    <url>%2F2019%2F01%2F25%2FLuogu-4593-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 4593 做法有个显然的结论，干掉这些怪需要亵渎的数量为$m+1$张，那么第一次亵渎的分数为 \sum\limits_{i=1}^{n}i^{m+1}-\sum\limits_{i=1}^{m}a_i^{m+1}而第二次到第$m+1$亵渎的分数也都是形如这个形式。后面一项求和的项数很少，我们可以直接暴力，而前面一项则是经典的自然数幂和问题，我们使用拉格朗日插值求解。对于$\sum\limits_{i=1}^{n}i^k$，我们把它看成一个关于n的函数，通过伯努利数或斯特林数或其他各种各样的做法我们知道他是一个$k+1$次函数，所以我们只要先暴力代入$i=[0,k+1]$计算答案，再暴力插值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;const int P=1000000007;int ans,m,T; int x[N],y[N],w[N];LL a[N];LL n;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int inv(int a)&#123; return ksm(a,P-2);&#125;void init()&#123; y[0]=0; x[0]=0; for (int i=1;i&lt;=m+1;i++)&#123; x[i]=i; y[i]=Inc(y[i-1],ksm(i,m)); //printf("%d %d\n",x[i],y[i]); &#125; for (int i=0;i&lt;=m+1;i++)&#123; w[i]=1; for (int j=0;j&lt;=m+1;j++)&#123; if (i!=j) w[i]=1ll*w[i]*(x[i]-x[j]+P)%P; &#125; w[i]=inv(w[i]); &#125;&#125;int query(LL t)&#123; int l=1; t%=P; for (int i=0;i&lt;=m+1;i++) if (t==x[i]) return y[i]; for (int i=0;i&lt;=m+1;i++) l=1ll*l*(t-x[i]+P)%P; int ans=0; for (int i=0;i&lt;=m+1;i++)&#123; ans=Inc(ans,1ll*y[i]*l%P*inv(Inc(t-x[i],P))%P*w[i]%P); &#125; //printf("query %lld %d\n",t,ans); return ans;&#125;int main()&#123; read(T); while (T--)&#123; read(n),read(m); for (int i=1;i&lt;=m;i++)&#123; read(a[i]); &#125; sort(a+1,a+m+1); m++; init(); ans=0; for (int i=1;i&lt;=m;i++)&#123; ans=Inc(ans,query(n-a[i-1])); for (int j=i;j&lt;m;j++)&#123; ans=Inc(ans-ksm((a[j]-a[i-1])%P,m),P); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值学习笔记]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言我们都知道两点确定一条直线，三个点确定一个二次函数，现在给你$n$个点，让你求出一个$n-1$次函数怎么做。 暴力直接把每个点看成一个方程，$x^0,x^1\dots x^{n-1}$的系数看成未知数，高斯消元解方程，复杂度为$n^3$ 朴素拉格朗日插值我们构造出函数$l_i(x)$，使得$x$取$x_i$时等于1，$x$取$x_1,x_2\dots x_n$(不包括$x_i$)时为0.设我们最后要求的函数为$f(x)$ f(x)=\sum\limits_{i=1}^{n}y_i*l_i(x)这步应该显然，接下里我们考虑如何构造$l_i(x)$。 l_i(x)=\prod\limits_{j=1,j\ne i}^{n}\frac{x-x_j}{x_i-x_j}显然是满足上面我们的要求的。但每次询问都要暴力插值，复杂度为$n^2$ 重心拉格朗日插值我们发现$l_i$的分子是有非常多的重复的。考虑令 l(x)=\prod\limits_{j=1}^{n}(x-x_j)那么 l_i(x)=\frac{l(x)}{x-x_i}\frac{1}{\prod_{j=1,j\ne i}^{n}(x_i-x_j)}再令 w_i=\frac{1}{\prod_{j=1,j\ne i}^{n}(x_i-x_j)}我们称$w_i$为重心权，所以这个插值方法也叫做重心拉格朗日插值最后 f(x)=\sum\limits_{i=1}^{n}y_i*\frac{l(x)}{x-x_i}*w_i这样的话可以做到每次修改一个点后，单次查询的复杂度就降到了$O(n)$ 代码贴上求单点值的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (2005)using namespace std;int n,k,l,ans;const int P=998244353;int w[N],x[N],y[N]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int inv(int a)&#123; return ksm(a,P-2);&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int main()&#123; read(n),read(k); for (int i=1;i&lt;=n;i++)&#123; read(x[i]),read(y[i]); &#125; for (int i=1;i&lt;=n;i++)&#123; w[i]=1; for (int j=1;j&lt;=n;j++)&#123; if (i!=j) w[i]=1ll*w[i]*(x[i]-x[j]+P)%P; &#125; w[i]=inv(w[i]); &#125; l=1; for (int i=1;i&lt;=n;i++) l=1ll*l*(k-x[i]+P)%P; ans=0; for (int i=1;i&lt;=n;i++)&#123; ans=Inc(ans,1ll*l*inv(Inc(k-x[i],P))%P*w[i]%P*y[i]%P); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3643] [APIO2016] 划艇]]></title>
    <url>%2F2019%2F01%2F24%2FLuogu-3643-APIO2016-%E5%88%92%E8%89%87%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3643 题目大意给你一个长度为n的数列，数列第i项可以取$[l_i,r_i]$，或者不取，使得最后取的数单调递增，问方案数，若所有数均不取不计入方案。$n\le 500,l_i\le r_i\le 1e9$ 做法我们先考虑这样一个问题，一个长度为n的数列，数列的每个数可以取$[1,L]$，使得数列单调递增的方案数。那么这个答案显然是$\binom{L}{n}$，当你选的数确定后，放的位置也自然就确定了。接下来将问题改为一个长度为n的数列，数列的每个数可以取$[1,L]$或不取，使得最后取的数单调递增的方案数。假设我们从这样一个数列中取n个数 0,0,\dots 0,0,1,2,3,\dots L-1,L前面总共有n个0。我们将每种取数的方案如下映射到一个数列上。如果取到第i个0，那么数列的第i位不取。剩下取到的非0的数按照升序依次填入取的位即可。这个映射显然是个双射，所以我们要求的答案即为$\binom{n+L}{n}$那么知道了这个有什么用呢？我们先将原先的值域离散成若干段左开右闭的区间，那么$[l_i,r_i]$就表示若干段左开右闭的区间了。考虑dp用$f_{i,j}$表示数列的前i项，第i项取在j这个区间中的方案数。再枚举k，表示数列的第k项取，并且取的区间小于j。也就是说数列的$[k+1,i-1]$这些要么不取，要么全部取在j这个区间中。根据我们上面的结论，转移即为 f_{i,j}=\sum\limits_{k=0}^{i-1}\binom{L+t}{t}\sum\limits_{p=1}^{j-1}f_{k,p}$L$表示$j$这段开区间的长度，t表示$[k+1,i]$中有多少个位置，能取的范围是包括$j$这段开区间的，(如果不包括，显然只能不取)对于后面这个式子我们用前缀和优化。k从大往小枚举，组合数可以$O(1)$递推。最后求答案并非是$\sum\limits_{j=1}^{\infty} f_{n,j}$，因为第n项可以不取，而$f_{i,j}$中i这一项是必须取的。所以我们考虑最后取的是哪一项，后面的都不取 ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{\infty}f_{i,j}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (505)using namespace std;int n,ans,t; int l[N],r[N],q[N&lt;&lt;1],f[N][N&lt;&lt;1],sum[N][N&lt;&lt;1],inv[N&lt;&lt;1];const int P=1000000007;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(l[i]),read(r[i]); q[++t]=l[i],q[++t]=r[i]+1; &#125; sort(q+1,q+t+1); t=unique(q+1,q+t+1)-q-1; inv[0]=inv[1]=1; for (int i=2;i&lt;=n;i++)&#123; inv[i]=Inc(1ll*-P/i*inv[P%i]%P,P); &#125; for (int i=1;i&lt;=n;i++)&#123; l[i]=lower_bound(q+1,q+t+1,l[i])-q; r[i]=lower_bound(q+1,q+t+1,r[i]+1)-q-1; &#125; f[0][0]=1; for (int j=0;j&lt;=t;j++) sum[0][j]=1; for (int i=1;i&lt;=n;i++)&#123; for (int j=l[i];j&lt;=r[i];j++)&#123; int fw=q[j+1]-q[j],C=fw,x=fw,y=1; for (int k=i-1;k&gt;=0;k--)&#123; f[i][j]=Inc(f[i][j],1ll*sum[k][j-1]*C%P); if (l[k]&lt;=j&amp;&amp;r[k]&gt;=j)&#123; C=1ll*C*(x+1)%P*inv[y+1]%P; x++,y++; &#125; &#125; &#125; //for (int j=1;j&lt;=t;j++) printf("%d %d %d\n",i,j,f[i][j]); sum[i][0]=f[i][0]; for (int j=1;j&lt;=t;j++) sum[i][j]=Inc(sum[i][j-1],f[i][j]); &#125; for (int i=1;i&lt;=n;i++) ans=Inc(ans,sum[i][t]); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min-25筛学习笔记]]></title>
    <url>%2F2019%2F01%2F16%2FMin-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言在yx大佬不厌其烦的帮助下终于还是学会了Min-25筛。其实不算特别难理解，主要是原先没人给讲解自己瞎走了许多弯路，代码实现也相对容易，听说可以代替杜教筛来求积性函数前缀和，名字好奇怪啊，不知道怎么来的复杂度O(\frac{n^\frac{3}{4}}{\log n})求单点时略优于杜教筛。update: Min-25是一位日本选手，精通数论，目前SPOJ rank10 orz，感谢daniel14311531 Min-25筛第一部分首先，如果要用Min-25筛有前置条件，即积性函数$f(i)$在i为质数时是个低次多项式，并且在i是质数的幂次时可以快速求得。既然$f(i)$在i是质数时是个低次多项式，我们不妨把这个多项式拆开，形如f(i)=i^{k_1}+i^{k_2}+i^{k_3}(i\in prime)显然每个幂次不会互相干扰，那么我们就分开处理。假设现在$f(i)=i^k(i\in prime)$并且$f$为完全积性函数，因为合数会被筛掉，所以没有影响。定义$P_i$表示第$i$小的质数，$sum_i$表示$\sum\limits_{j=1}^{i}f(P_j)$，$Minn_i$表示$i$的最小质因数$g(n,i)表示\sum\limits_{j=2}^{n}[Minn_j&gt;P_i或j\in prime]f(j)$可以理解为用前$i$个质数做埃氏筛后剩下的数的$f$的和。考虑如何计算$g(n,i)$。由于是个埃氏筛的过程，我们考虑第i个质数会筛掉哪些合数。显然会筛掉最小的合数为$P_i^2$如果$P_i^2&gt;n$，那么啥都筛不掉，$g(n,i)=g(n,i-1)$如果$P_i^2\le n$，那么$P_i的[P_i,\frac{n}{P_i}]$倍都会被筛掉。$[P_i,\frac{n}{P_i}]$这些答案存在$g(\frac{n}{P_i},i-1)$中，但是这里面还包括了$P_1,P_2…P_{i-1}$这些质数。所以$g(n,i)=g(n,i-1)-f(P_i)*(g(\frac{n}{P_i},i-1)-sum_{i-1})$发现n的取值都形如$\lfloor \frac{a}{b}\rfloor$，通过整数分块，预处理这$2*\sqrt{n}$个值的g即可。利用滚动数组完成递推 第二部分我们令$S(n,m)$表示$\sum\limits_{i=2}^{n}[Minn_i\ge P_m]f(j)$我们要求的$S(n,1)$考虑质数的贡献，显然是$g(n,\infty)-sum_{m-1}$考虑合数的贡献，不能从$g$中直接得到，因为$g$中对于合数我们假设他为完全积性函数，而事实上并不是，这样做只是方便计算质数。我们枚举每个合数的最小质因数，已及最小质因数的次数(否则无法积性函数)，那么贡献为 \sum_{i=m}^{\infty} \sum_{t\ge 1, P_i^{t+1}\le n}\left( S(\lfloor \frac{n}{P_i^t} \rfloor,i+1) * f(P_i^t) + f(P_i^{t+1}) \right)结合定义应该可以理解，与求g的过程相似。S递归解决即可。 例题Luogu 4213 Sum让你求\sum_{i=1}^{n}\phi(i)和\sum_{i=1}^{n}\mu(i)我们以求$\phi$为例，$f(i)=i-1(i\in prime)$，我们把按照上面的说法分成$f(i)=i和f(i)=-1$分别把g求出来，合并后求S即可。求$\mu$没有本质的区别。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1000005)using namespace std;int T,n,pri,t,unit;int prime[N],q[N],id1[N],id2[N];LL g[N],h[N],sum[N];bool nprime[N]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void init()&#123; pri=t=0; unit=sqrt(n); for (int i=2;i&lt;=unit;i++)&#123; if (!nprime[i]) prime[++pri]=i,sum[pri]=sum[pri-1]+i; for (int j=1;j&lt;=pri&amp;&amp;i*prime[j]&lt;=unit;j++)&#123; nprime[i*prime[j]]=1; if (i%prime[j]==0) break; &#125; &#125; for (int i=1;i&lt;=n;)&#123; int v=n/i,R=n/v; q[++t]=v; if (v&lt;=unit) id1[v]=t; else id2[R]=t; g[t]=1ll*v*(v+1)/2-1; h[t]=v-1; i=R+1; &#125;&#125;inline int id(int x)&#123; return (x&lt;=unit)?id1[x]:id2[n/x];&#125; LL S(int n,int m)&#123; if (n&lt;=1||prime[m]&gt;n) return 0; LL ret=g[id(n)]-sum[m-1]+m-1; for (int k=m;prime[k]*prime[k]&lt;=n&amp;&amp;k&lt;=pri;k++)&#123; for (int v=prime[k],p1=prime[k]-1;1ll*v*prime[k]&lt;=n;v=v*prime[k],p1=p1*prime[k]) ret+=(S(n/v,k+1)+prime[k])*p1; &#125; return ret;&#125;LL D(int n,int m)&#123; if (n&lt;=1||prime[m]&gt;n) return 0; LL ret=h[id(n)]+(m-1); for (int k=m;prime[k]*prime[k]&lt;=n&amp;&amp;k&lt;=pri;k++)&#123; ret-=D(n/prime[k],k+1); &#125; return ret;&#125;signed main()&#123; read(T); while (T--)&#123; read(n); init(); for (int i=1;i&lt;=pri;i++)&#123; int v=prime[i]*prime[i]; for (int j=1;j&lt;=t&amp;&amp;v&lt;=q[j];j++)&#123; int k=id(q[j]/prime[i]); g[j]-=1ll*prime[i]*(g[k]-sum[i-1]); h[j]-=h[k]-i+1; &#125; &#125; for (int i=1;i&lt;=t;i++) g[i]-=h[i],h[i]=-h[i]; printf("%lld %lld\n",S(n,1)+1,D(n,1)+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Min-25筛</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 4859] 已经没有什么好害怕的了]]></title>
    <url>%2F2019%2F01%2F15%2FLuogu-4859-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%2F</url>
    <content type="text"><![CDATA[题目链接[Luogu 4859] 已经没有什么好害怕的了 做法用$a$表示药片数组，$b$表示糖果数组，两个数组都先升序排列。考虑dp，$f_{i,j}$表示前$i$个数中有$j$对$a&gt;b$的方案数，我们这里认为每个a有两种选择，一是选择一个比他小的b来组成新的一对，二是空着不选择，而不是选择一个比他大的b，一定要注意。那么根据上面的定义，可以得到dp方程，f_{i,j}=f_{i-1,j}+f_{i-1,j-1}*(now_i-j+1)由于b是升序，所以对于$a_i$，比它小的b一定是一个前缀，所以$now_i$表示b中比我小的是$[1,now_i]$，因为a也是升序，所以$now_i$一定是单调不降的，我们用一个指针维护即可。那么dp出$f$之后有什么用呢?我们用$ans_i$表示最后所有点都有匹配后$a&gt;b$的对数有$i$对的方案数($f$中不是有些还没匹配吗)，我们最后要求的就是$ans_\frac{n+k}{2}$发现$ans$并不好求，定义$g_i$表示最后所有点都有匹配后$a&gt;b$的对数有大于$i$对的方案数，那么我们将a中原先没有匹配的点随意匹配，即g_i=f_{n,i}*(n-i)!发现$ans_i$对于$g_j$的贡献即为$\binom{i}{j}(i\ge j)$也就是说 g_j=\sum\limits_{i=j}^{n}\binom{i}{j}ans_i可以二项式反演 ans_j=\sum\limits_{i=j}^{n}\binom{i}{j}*(-1)^{i-j}*g_i直接枚举算出$ans_\frac{n+k}{2}$即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#define N (2005)#define LL long longusing namespace std;int n,k,r,ans,d;int a[N],b[N],f[N][N],C[N][N],g[N],jc[N];const int P=1000000009;inline bool cmp(int a,int b)&#123; return a&gt;b;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(n),read(k); if ((n+k)&amp;1)&#123; puts("0"); return 0; &#125; for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;=n;i++) read(b[i]); sort(a+1,a+n+1); sort(b+1,b+n+1); f[0][0]=1; r=0; for (int i=1;i&lt;=n;i++)&#123; for (;r&lt;n&amp;&amp;b[r+1]&lt;a[i];r++); for (int j=0;j&lt;=n;j++)&#123; f[i][j]=f[i-1][j]; if (j&amp;&amp;r&gt;=j) f[i][j]=Inc(f[i][j],1ll*f[i-1][j-1]*(r-j+1)%P); &#125; &#125; C[0][0]=1; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) C[i][j]=Inc(C[i-1][j],C[i-1][j-1]); C[i][0]=1; &#125; jc[0]=1; for (int i=1;i&lt;=n;i++) jc[i]=1ll*jc[i-1]*i%P; for (int i=0;i&lt;=n;i++) g[i]=1ll*f[n][i]*jc[n-i]%P; k=(n+k)/2; d=1; for (int i=k;i&lt;=n;i++)&#123; ans=Inc(ans,1ll*C[i][k]*g[i]%P*d); ans=Inc(ans,P); d=-d; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆方树学习笔记]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%9C%86%E6%96%B9%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言既然老师讲课都讲过了，那还是要学的，本篇文章介绍的圆方树为狭义的圆方树，解决仙人掌上的系列问题。 仙人掌仙人掌，每条边至多属于一个简单环的连通无向图。图中没有自环，但是有可能有重边。 圆方树圆方树做的事情就是把仙人掌的每个环拿出来，建一个新的方点，环的起点向方点连边，方点再向环上其他点连边，原先非环边保留。注意这里点边都只从父亲连向孩子。上面那个仙人掌建出的圆方树就是这样的罗马数字的点为方点。 建树通过tarjan一边求点双一边连边。tarjan没有什么不同，建树的部分请结合代码和注释理解。123456789101112131415161718192021cnt=n;void tarjan(int u,int fa)&#123;//由于有重边，fa存边的编号 dfn[u]=low[u]=++tim; stk[++top]=u; for (int p=head[u];p;p=nxt[p])&#123; if (p!=fa)&#123; int v=tow[p]; if (!dfn[v])&#123; tarjan(v,p^1); low[u]=min(low[u],low[v]); if (dfn[v]==low[v]) s[u].push_back(v);//如果v不在我这个环内，直接连边 &#125; else if (dfn[v]&lt;dfn[u])&#123;//显然整个环中，环的起点dfn最小，所以v即为环的起点 low[u]=min(low[u],dfn[v]); s[v].push_back(++cnt);//建方点 for (int j=top;stk[j]!=v;j--) s[cnt].push_back(stk[j]); &#125; &#125; &#125; top--;&#125; 这样就把圆方树给建出来了，剩下我们要做的就是根据题目的要求，在圆方树上树形dp就行了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>连通分量</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 2541]「PKUWC2018」猎人杀]]></title>
    <url>%2F2019%2F01%2F09%2FLOJ-2541-%E3%80%8CPKUWC2018%E3%80%8D%E7%8C%8E%E4%BA%BA%E6%9D%80%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 2541 做法以$sum(S)$表示S这个集合中所有人的仇恨值的和。我们先求$P(S)$表示S中所有的人一定死在第一个人之后的概率，其他人随意。显然其他人什么时候死我不关心，只考虑下一枪打在S中或者打在1上，所以$P(S)=\frac{a_1}{sum(S)+a_1}$。考虑最后计算答案，所有人都不能死在1后面。通过容斥可以得到每个状态S的贡献为，$P(S)*(-1)^{|S|}$直接计算显然复杂度过大，但是$sum(S)$并不大。由于容斥系数有-1和1，把方案变成系数和即可。用$f[i][j]$表示从第二个人开始前i个人，仇恨值为j的系数和。转移时，考虑第i个人选不选。如果不选$f[i][j]=f[i-1][j]$如果选的话，|S|的奇偶性改变，所以系数取负，$f[i][j]-=f[i-1][j-a[i]]$最后计算答案枚举j即可。这样可以获得50分的成绩。发现每次转移等价于乘上一个生成函数$(x^0-x^{a[i]})$，用分治+NTT解决。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#define LL long long#define N (100005)using namespace std;int n,val,ans,G=3,invG,invL,lim;int a[N],R[N&lt;&lt;2];vector &lt;int&gt; f; const int P=998244353;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;void NTT(vector &lt;int&gt; &amp;f,int lim,int G)&#123; for (int i=0;i&lt;lim;i++)&#123; R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*lim&gt;&gt;1); if (i&gt;R[i]) swap(f[i],f[R[i]]); &#125; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; int w0=ksm(G,(P-1)/(i&lt;&lt;1)); for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; int w=1; for (int k=j;k&lt;i+j;k++)&#123; int t=1ll*f[k+i]*w%P; f[k+i]=Inc(f[k]-t,P); f[k]=Inc(f[k],t); w=1ll*w*w0%P; &#125; &#125; &#125; int invL=ksm(lim,P-2); if (G!=3)&#123; for (int i=0;i&lt;lim;i++) f[i]=1ll*f[i]*invL%P; &#125;&#125;int solve(int l,int r,vector &lt;int&gt; &amp;f)&#123; if (l==r)&#123; f.resize(a[l]+1); f[a[l]]=P-1,f[0]=1; return a[l]; &#125; int mid=l+r&gt;&gt;1; vector &lt;int&gt; f0,f1; int len=solve(l,mid,f0)+solve(mid+1,r,f1); for (lim=1;lim&lt;=len;lim&lt;&lt;=1); f0.resize(lim),f1.resize(lim),f.resize(lim); NTT(f0,lim,G),NTT(f1,lim,G); for (int i=0;i&lt;lim;i++) f[i]=1ll*f0[i]*f1[i]%P; NTT(f,lim,invG); return len;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++) read(a[i]),val+=a[i]; invG=ksm(G,P-2); solve(2,n,f); for (int j=0;j&lt;val;j++)&#123; ans=Inc(ans,1ll*a[1]*ksm(a[1]+j,P-2)%P*f[j]%P); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>生成函数</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 2542]「PKUWC2018」随机游走]]></title>
    <url>%2F2019%2F01%2F09%2FLOJ-2542-%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%2F</url>
    <content type="text"><![CDATA[前言到这里PKUWC2018的题目，斗地主不是题目，就算都补完了，希望今年的PKUWC可以有好运吧。 题目链接LOJ 2542 做法显然可以Min-Max容斥，不会的戳这儿。我们要求的是$Max(S)$，所以我们考虑$Min(S)$如何计算。$Min(S)$实际上求的就是从起点出发，走到S中任意一个点的期望时间。我们枚举S，以$f_i$表示从i出发走到S中任意一个点的期望时间，$d_i$表示i这个点的度。如果$i\in S$，那么$f_i=0$，否则$f_i=\frac{\sum\limits_{i\to j}f_j}{d_i}+1$那么我对这些方程高斯消元，复杂度$2^n*n^3$过大。发现这个消元实际上是在树上进行，那么我们用树上消元的经典trick来解决。将$f_i$用$k_i*f_{fa(i)}+b_i$表示，那么我们将原方程变形。$d_i*f_i=\sum\limits_{j\in son_i}f_j+f_{fa(i)}+d_i$再将$f(j)$全部用$k_j*f_i+b_j$替换，用$kk$表示$\sum\limits_{j\in son_i}k_j$，$bb$表示$\sum\limits_{j\in son_i}b_j$那么可以得到$d_i*f_i=kk*f_i+bb+f_{fa(i)}+d_i$再将$f(i)$用$k_i*f_{fa(i)}+b_i$替换，移项。$(d_i-kk)*k_i*f_{fa(i)}+(d_i-kk)*b_i=bb+f_{fa(i)}+d_i$左右两边恒等，这样我们就能解出$k_i$和$b_i$了。根节点的$f_{fa(i)}$为0，所以根节点$f_i=b_i$，而我们只需要起点的f，所以把起点提到根，做一遍上述的消元就解出了所有的$Min(S)$由于Min-Max容斥本质上是个带系数的子集卷积。$Max(S)=\sum\limits_{S’\subseteq S}Min(S’)*(-1)^{|S’|-1}$如果$|S’|$是偶数的话我们把它的系数变为-1，用$FWT$做一遍子集前缀和就行了，回答变为$O(1)$，而$|S’|$就是$S’.popcount()$总复杂度$O(2^n*n+Q)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (25)using namespace std;int n,q,x,tot,now,st,lim,y,zt;const int P=998244353;int tow[N&lt;&lt;1],head[N],nxt[N&lt;&lt;1],fa[N],k[N],b[N],d[N],f[N],inv[N],ans[1&lt;&lt;18],pp[1&lt;&lt;18]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; tow[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125; void dfs(int u)&#123; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u])&#123; fa[v]=u; dfs(v); &#125; &#125;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;void dfs1(int u)&#123; int kk=0,bb=0; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u])&#123; dfs1(v); kk=Inc(kk,k[v]),bb=Inc(bb,b[v]); &#125; &#125; if ((1&lt;&lt;(u-1))&amp;now)&#123; k[u]=b[u]=0; return; &#125; kk=1ll*kk*inv[d[u]]%P; bb=1ll*bb*inv[d[u]]%P; kk=ksm(Inc(1-kk,P),P-2); k[u]=1ll*ksm(d[u],P-2)*kk%P; b[u]=1ll*kk*(bb+1)%P;&#125;void FWT(int *f)&#123; lim=1&lt;&lt;n; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; for (int k=j;k&lt;j+i;k++)&#123; f[i+k]=Inc(f[k],f[i+k]); &#125; &#125; &#125;&#125;int main()&#123; read(n),read(q),read(st); inv[0]=inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=Inc(1ll*-P/i*inv[P%i]%P,P); for (int i=1;i&lt;n;i++)&#123; read(x),read(y); d[x]++,d[y]++; add(x,y),add(y,x); &#125; dfs(st); for (now=1;now&lt;(1&lt;&lt;n);now++)&#123; dfs1(st); ans[now]=b[st]; //printf("test %d %d\n",now,ans[now]); &#125; for (int i=1;i&lt;(1&lt;&lt;n);i++)&#123; pp[i]=pp[i&gt;&gt;1]+(i&amp;1); if (!(pp[i]&amp;1)) ans[i]=-ans[i]+P; &#125; FWT(ans); while (q--)&#123; read(x); zt=0; for (int i=1;i&lt;=x;i++) read(y),zt+=(1&lt;&lt;y-1); printf("%d\n",ans[zt]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>树上高斯消元</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3175] [HAOI2015]按位或]]></title>
    <url>%2F2019%2F01%2F07%2FLuogu-3175-HAOI2015-%E6%8C%89%E4%BD%8D%E6%88%96%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3175 [HAOI 2015] 按位或 做法为了表述的方便，下面称集合S为状态S，因为集合S本质上是表示二进制上某些位为1，某些位为0的状态，定义S中的权值为S这个状态的每一位1出现的期望时间。直接套Min-Max容斥的结论， E(Max(S))=\sum_{S'\subseteq S}(-1)^{|S'|-1}E(Min(S'))$E(Max(2^{n}-1))$就是我们要求的答案。对于$E(Min(S))$，考虑定义，它的值应该等于所有与S有交集的状态的概率和，再取倒数。即E(Min(S))=\frac{1}{\sum_{S'\cap S\ne \varnothing}p[S']}有交集的状态不好求，那么考虑求与我没有交集的状态，显然这些状态就是我补集的子集，所以我们先FWT一下求出子集和，然后暴力套公式就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (25)using namespace std;int n,lim,d;int pc[1&lt;&lt;20];double p[1&lt;&lt;20],ans; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void FWT(double *f)&#123; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; for (int k=j;k&lt;i+j;k++)&#123; f[i+k]+=f[k]; &#125; &#125; &#125;&#125;int main()&#123; read(n); for (int i=0;i&lt;(1&lt;&lt;n);i++) scanf("%lf",&amp;p[i]); for (int i=0;i&lt;(1&lt;&lt;n);i++) pc[i]=pc[i&gt;&gt;1]+(i&amp;1); lim=1&lt;&lt;n; FWT(p); for (int i=1;i&lt;(1&lt;&lt;n);i++)&#123; double k=1-p[(1&lt;&lt;n)-1-i]; if (pc[i]&amp;1) d=1; else d=-1; if (k==0)&#123; puts("INF"); return 0; &#125; ans=ans+(1/k)*d; &#125; printf("%.10lf",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>FWT</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 2839] 集合计数]]></title>
    <url>%2F2019%2F01%2F06%2FBZOJ-2839-%E9%9B%86%E5%90%88%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[链接BZOJ 2839 集合计数 题目大意一个有$n$个元素的集合有$2^n$个不同子集（包含空集），现在要在这$2^n$个集合中取出若干集合（至少一个），使得它们的交集的元素个数为K，求取法的方案数，对1e9+7取模 做法直接求比较困难，我们考虑先求出$a_i$表示交集大小至少为i的方案数。那么这i个数的取法是$\binom{n}{i}$，剩下的$n-i$个元素取或不取有$2^{n-i}$中选择，而这么多集合分别又有取或不取两种选择，所以$a_i=\binom{n}{i}*(2^{2^{n-i} }-1)$减1是因为至少取一个，把全部不取的情况减掉。知道这个之后我们考虑构造容斥系数$f_i$，使得$ans=\sum\limits_{i=0}^{n}f_i*a_i$那么怎么求这个$f$呢，我们考虑每种交集恰好为$x$的选法，对于每个$a_i$的贡献的总和。由于选取的集合已经固定，所以对于每个$a[i]$的贡献就是$\binom{x}{i}$，总贡献为$\sum\limits_{i=0}^{x}f_i\binom{x}{i}$定义kronecker delta函数$g(x,k)$，即$g(x)=[x=k]$我们对于交集恰好为k的函数应该对最后答案有1的贡献。所以$g(x)=\sum\limits_{i=0}^{x}f_i\binom{x}{i}$那么我们可以二项式反演二项式反演证明戳这里$f_{n}=\sum\limits_{i=0}^{n}(-1)^{n-i}\binom{n}{i}g(i)$由于只有$g(k)=1$，所以$f_i=(-1)^{i-k}\binom{i}{k}*[i&gt;=k]$再将$f$带入到最上面求$ans$的式子里就行了。$ans=\sum\limits_{i=k}^{n}(-1)^{i-k}\binom{i}{k}\binom{n}{i}*(2^{2^{n-i} }-1)$代码实现的时候$(2^{2^{n-i} }-1)$不好处理，我们可以$i$从倒序枚举，$2^{2^{n}}=(2^{2^{n-1} })^2$计算 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1000005)using namespace std;int n,k,d,base,ans;int jc[N],A[N],inv[N],f[N],a[N];const int P=1000000007;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline int ksm(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=1ll*a*a%P) if (b&amp;1) ret=1ll*ret*a%P; return ret;&#125;inline int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int C(int a,int b)&#123; return 1ll*jc[a]*inv[a-b]%P*inv[b]%P;&#125;int main()&#123; read(n),read(k); A[0]=A[1]=1; for (int i=2;i&lt;=n;i++) A[i]=Inc(1ll*-P/i*A[P%i]%P,P); jc[0]=inv[0]=1; for (int i=1;i&lt;=n;i++)&#123; jc[i]=1ll*jc[i-1]*i%P; inv[i]=1ll*inv[i-1]*A[i]%P; &#125; base=2; if ((n-k)&amp;1) d=-1; else d=1; for (int i=n;i&gt;=k;i--)&#123; ans=(1ll*d*C(i,k)*C(n,i)%P*(base-1)%P+ans+P)%P; base=1ll*base*base%P; d=-d; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二项式反演学习笔记]]></title>
    <url>%2F2019%2F01%2F06%2F%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[二项式反演如果我们现在有一个式子$f_{n}=\sum\limits_{i=0}^{n}\binom{n}{i}g_{i}$告诉我们所有的f，让我们求g这时候就要用到二项式反演了。$g_{n}=\sum\limits_{i=0}^{n}(-1)^{n-i}\binom{n}{i}f_{i}$考虑直接代入$g_{n}=\sum\limits_{i=0}^{n}(-1)^{n-i}\binom{n}{i}\sum\limits_{j=0}^{i}\binom{i}{j}g_{j}$换一下枚举顺序$g_{n}=\sum\limits_{j=0}^{i}g_{j}\sum\limits_{i=j}^{n}(-1)^{n-i}\binom{n}{i}\binom{i}{j}$把后面两个组合数暴力展开可以得到$\binom{n}{i}\binom{i}{j}=\binom{n}{j}\binom{n-j}{n-i}$把所有和i无关的项都提前$g_{n}=\sum\limits_{j=0}^{n}g_{j}\binom{n}{j}\sum\limits_{i=j}^{n}(-1)^{n-i}\binom{n-j}{n-i}$发现后面这个$\sum\limits_{i=j}^{n}(-1)^{n-i}\binom{n-j}{n-i}$ 就是二项式定理。当$j=n$时为1其他时候为$(-1+1)^{n-j}=0$所以$g_n=g_n$结论得证 例题BZOJ 2839 集合计数BZOJ 2839 集合计数 题解Luogu 4859 已经没有什么好害怕的了Luogu 4859 已经没有什么好害怕的了 题解]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 4707] 重返现世]]></title>
    <url>%2F2019%2F01%2F06%2FLuogu-4707-%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96%2F</url>
    <content type="text"><![CDATA[前言这篇文章的前置知识是Min_Max容斥，不会的同学可以先看一下我的另一篇博客Min-Max容斥学习笔记里面有详细的证明。 题目链接Luogu 4707 重返现世 做法这道题实际上就是要就是要我们求全集合出现第$n-k+1$大元素的期望时间。直接套用kth Min-Max容斥的结论。$E(kthMax(S))=\sum_{S’\subseteq S}E(Min(S’))*(-1)^{|S’|-k}*\binom{|S’|-1}{k-1}$$E(Min(S’))=\frac{m}{\sum_{i\in S’}P(i)}$发现m的范围并不大，那么我们考虑dp令$sum(S)$表示$\sum_{i\in S}P(i)$，$U$表示全集$g_{i,j}$表示对于集合S，$|S|=i$，$sum(S)=j$的方案数。转移只要考虑每次加进来一个数是否放到集合中就行了，答案的计算应该也是显然的，这里不多赘述了。但是这样dp的复杂度是$O(n^2*m)$的，难以接受。观察到还有$|n-k|\le 10$的限制条件，考虑改变dp状态$f_{i,j}$表示对于集合S，$sum(S)=i$，出现第j大元素的期望时间的总和，显然$1 \le j \le |n-k|$但是直接求期望时间不方便处理，考虑把期望时间拿掉。用式子写出来$f_{i,j}=\sum_{S’ \subseteq U}(-1)^{|S’|-j}*\binom{|S’|-1}{j-1}*[sum(S’)=i]$考虑加入第t个物品:如果不加入，则直接继承答案如果加入的话，答案应该和$f_{i-p[t],j}$有关。仍然用$g_{i,j}$表示对于集合S，$|S|=i$，$sum(S)=j$的方案数。考虑展开$f_{i-p[t],j}$，把枚举集合变为枚举集合的大小。那么$f_{i-p[t],j}=\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k-1}{j-1}*(-1)^{k-j}$再考虑$\Delta f_{i,j}$，枚举转移过来的集合的大小k$\Delta f_{i,j}=\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k}{j-1}*(-1)^{k-j+1}$两个式子做加法$\Delta f_{i,j}+f_{i-p[t],j}=\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k}{j-1}*(-1)^{k-j+1}+\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k-1}{j-1}*(-1)^{k-j}$后面一项添个-1，将公因式提取一下得到$\Delta f_{i,j}+f_{i-p[t],j}=\sum_{k=1}^{n}g_{k,i-p[t]}*[\binom{k}{j-1}-\binom{k-1}{j-1}]*(-1)^{k-j+1}$也就是$\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k-1}{j-2}*(-1)^{k-j+1}$而$(-1)^{k-j+1}=(-1)^{k-j-1}$那么$\sum_{k=1}^{n}g_{k,i-p[t]}*\binom{k-1}{j-2}*(-1)^{k-j+1}=f_{i-p[t],j-1}$所以我们dp就可以递推了，枚举第$t$个物品是否加入，滚动一下，用$f’$表示枚举到第$t-1$个物品时的状态。$f_{i,j}=f’_{i,j}-f’_{i-p[t],j}+f’_{i-p[t],j-1}$再考虑一下临界状态，直接代入可以知道$f_{p[t],1}=1$，所以只要$f_{0,0}=1$就行了，实际上$j=0$没有意义，所以其他时候不用转移。最后算答案的时候也很简单。枚举$i$，令$j=k$，$ans+=\frac{f[i][j]*m}{j}$就好了 复杂度$O(n*m*|n-k|)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (10005)using namespace std;int n,K,m,d,ans;const int P=998244353;int a[N],f[2][N][11],inv[N]; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int main()&#123; read(n),read(K),read(m); K=n-K+1; inv[0]=inv[1]=1; for (int i=2;i&lt;=m;i++) inv[i]=(1ll*-P/i*inv[P%i]%P+P)%P; for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;=n;i++)&#123; f[d][0][0]=1; d^=1; for (int j=1;j&lt;=m;j++)&#123; for (int k=1;k&lt;=K;k++)&#123; f[d][j][k]=f[d^1][j][k]; if (j&gt;=a[i])&#123; f[d][j][k]=Inc(f[d][j][k],f[d^1][j-a[i]][k-1]); f[d][j][k]=Inc(f[d][j][k]-f[d^1][j-a[i]][k],P); &#125; &#125; &#125; &#125; for (int j=0;j&lt;=m;j++)&#123; ans=Inc(ans,1ll*f[d][j][K]*inv[j]%P*m%P); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min-Max容斥学习笔记]]></title>
    <url>%2F2019%2F01%2F05%2FMin-Max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言PKUWC2018的D2T3好像是个Min-Max容斥板子题，还是要学习一下的。 用途给定一个集合S，告诉你其中每个元素单位时间出现的概率，问你每个元素至少出现一次的期望时间。 Min-Max容斥做这道题我们需要用到Min-Max容斥的结论，这里先来证明Min-Max容斥的正确性。需要二项式反演的基础知识，不会二项式反演戳这里给定集合S，令$Max(S)$为S中的最大值，$Min(S)$为S中的最小值，有结论$Max(S)=\sum\limits_{S’\subseteq S}Min(S’)*(-1)^{|S’|-1}$这为什么是对的呢。我们先考虑构造容斥系数$f$，使得$Max(S)=\sum\limits_{S’\subseteq S}Min(S’)*f_{|S’|}$枚举第$x+1$大值的贡献，也就是有多少个集合的最小值是全集的第$x+1$大值。那么比我大的x个可以随便选。这个值为$\sum\limits_{i=0}^{x}\binom{x}{i}*f_{i+1}$考虑会对最后答案有贡献的只有$x=0$的时候，所以定义kronecker delta函数$g(x)=[x=0]$$g(x)=\sum\limits_{i=0}^{x}\binom{x}{i}*f_{i+1}$直接二项式反演得到$f_{x+1}=\sum\limits_{i=0}^{x}\binom{x}{i}*g_{i}*(-1)^{x-i}$由于$g$只在$i=0$时为1，所以$f_{x+1}=(-1)^{x}$$f_{x}=(-1)^{x-1}$$Max(S)=\sum\limits_{S’\subseteq S}Min(S’)*(-1)^{|S’|-1}$同时这个结论在期望意义下也是成立的，那么这道题就可以做了。 做法对于一个集合S，我们定义它的权值为它出现的时间。$Min(S)$表示这个集合中最小的元素$Max(S)$表示这个集合中最大的元素$P[i]$表示i这个元素单位时间出现的概率，$E$表示期望时间显然有$Min(S)=\sum\limits_{i\in S}P(i)$，而$E(Min(S))=\frac{1}{P(Min(S))}$然后Min-Max容斥告诉我们$E(Max(S))=\sum\limits_{S’\subseteq S}E(Min(S’))*(-1)^{|S’|-1}$注意特判$S’$不能是空集。 例题例题一贴个板子题先。Hdu 4336 Card Collector考虑每张牌如果都要出现，那么就是求$Max(全集)$，直接套公式做就好了。 例题二Luogu 3175 [HAOI 2015] 按位或Luogu 3175 [HAOI 2015] 按位或 题解 例题三LOJ 2542「PKUWC2018」随机游走LOJ 2542「PKUWC2018」随机游走 题解 kth Min-Max容斥顾名思义，就是可以求第k大元素出现的期望时间。上面的公式求的是最大元素出现的期望时间，下面给出求第k大元素出现期望时间的公式。$E(kthMax(S))=\sum\limits_{S’ \subseteq S}E(Min(S’))*(-1)^{|S’|-k}*\binom{|S’|-1}{k-1}$把k=1带进去就得到了前面的那个公式。证明思路与$k=1$时如出一辙先构造容斥系数$f$，使得$kthMax(S)=\sum\limits_{S’\subseteq S}Min(S’)*f_{|S’|}$考虑第$x+1$大值的贡献这个值为$\sum\limits_{i=0}^{x}\binom{x}{i}*f_{i+1}$考虑会对最后答案有贡献的从$x=0$变为了$x=k-1$的，所以定义kronecker delta函数$g(x)=[x=k-1]$$g(x)=\sum\limits_{i=0}^{x}\binom{x}{i}*f_{i+1}$二项式反演$f_{x+1}=\sum\limits_{i=0}^{x}\binom{x}{i}*g_{i}*(-1)^{x-i}$由于$g$只在$i=k-1$时为1，所以$f_{x+1}=(-1)^{x-k+1}*\binom{x}{k-1}$$f_{x}=(-1)^{x-k}*\binom{x-1}{k-1}$$kthMax(S)=\sum\limits_{S’ \subseteq S}Min(S’)*(-1)^{|S’|-k}*\binom{|S’|-1}{k-1}$同样在期望意义下是对的。也贴个题Luogu 4707 重返现世Luogu 4707 重返现世 题解]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态DP及全局平衡二叉树学习笔记]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%8A%A8%E6%80%81DP%E5%8F%8A%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言受到NOIP的影响，大家都开始学习动态dp，博主比较菜，学的比较晚，以下的学习笔记主要是配合例题和代码讲解。 例题例题一 【模板】动态dpLuogu P4719【模板】动态dp 题目大意给定一个$n$个点的树，每个点有点权$a[i]$。有$m$次修改操作，每次操作给定$x,y$表示将$a[x]$修改为$y$你需要每次修改后找出若干个点，使得这些点互不相邻，并且点权和最大。$ n,m\le 1e5$ 分析 首先考虑不带修的情况，我们令$f[i][1]$表示以i为根的子树，选了i这个的点最大点权，$f[i][0]$表示不选i这个点时的最大点权和。我们以$u\to v$表示v是u的字节点考虑转移$f[u][1]=a[u]+\sum_{u\to v}f[v][0],f[u][0]=\sum_{u\to v}Max(f[v][0],f[v][1])$应该非常显然，不做赘述。 现在我们考虑要支持修改了。先树链剖分，以$son[u]$表示u的重儿子，那么原来的转移方程可以变为$f[u][1]=a[u]+\sum_{u\to v,v\ne son[u]}f[v][0]+f[son[u]][0]$$f[u][0]=\sum_{u\to v,v\ne son[u]}Max(f[v][0],f[v][1])+Max(f[son[u]][0],f[son[u]][1])$我们令$g[u][0]=\sum_{u\to v,v\ne son[u]}Max(f[v][0],f[v][1])$$g[u][1]=a[u]+\sum_{u\to v,v\ne son[u]}f[v][0]$也就是f中除了重儿子的部分那么我们的dp就可以化为$f[u][1]=g[u][1]+f[son[u]][0]$$f[u][0]=g[u][0]+Max(f[son[u]][0],f[son[u]][1])$再用矩阵来描述每一次转移把矩阵乘法重新定义一下。$c[i][j]=\sum_{k=1}^{n}a[i][k]*b[k][j] \to c[i][j]=Max(a[i][k]+a[k][j])$这样的矩阵乘法也是满足结合律的假装是吧，博主也不会证那么 \left[ \begin {matrix} g[u][0]&g[u][0]\\g[u][0]&-\infty \end {matrix} \right] \left[ \begin {matrix} f[son[u]][0]\\f[son[u]][1] \end {matrix} \right] = \left[ \begin {matrix} f[u][0]\\f[u][1] \end {matrix} \right]重儿子上的信息每次在线段树上查询，轻儿子的信息直接暴力维护。每次修改一个点。(1)先将自己的矩阵改掉(2)跳到重链顶端，暴力修改重链顶端的父亲的矩阵(3)跳到重链顶端的父亲重复步骤(1)(2)(3)直至跳到节点0由于最多跳log条重链，每次修改前要线段树上查询我的f值，所以修改一次的总复杂度是$log^2$的。查询的复杂度为$log$，所以总复杂度为$n*log^2(n)$代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,m,tot,cnt,x,y;int a[N],son[N],tow[N&lt;&lt;1],nxt[N&lt;&lt;1],head[N],size[N],dep[N],top[N],down[N],dfn[N],g[N][2],f[N][2],fnd[N],fa[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; tow[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void dfs(int u)&#123; f[u][0]=0; f[u][1]=a[u]; size[u]=1; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u])&#123; fa[v]=u; dfs(v); f[u][0]+=max(f[v][0],f[v][1]); f[u][1]+=f[v][0]; size[u]+=size[v]; if (size[v]&gt;size[son[u]]) son[u]=v; &#125; &#125;&#125;void dfs1(int u,int f)&#123; dfn[u]=++cnt; fnd[cnt]=u; top[u]=f; down[f]=dfn[u]; if (son[u]) dfs1(son[u],f); for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u]&amp;&amp;v!=son[u]) dfs1(v,v); &#125;&#125;struct matrix&#123; int a[2][2]; inline matrix()&#123;memset(a,0,sizeof(a));&#125;; inline matrix(int x,int y)&#123;a[0][0]=a[0][1]=x,a[1][0]=y,a[1][1]=-1e9;&#125; inline matrix operator * (const matrix &amp;t) const&#123; matrix ret; for (int i=0;i&lt;=1;i++)&#123; for (int j=0;j&lt;=1;j++)&#123; ret.a[i][j]=max(a[i][0]+t.a[0][j],a[i][1]+t.a[1][j]); &#125; &#125; return ret; &#125;&#125;;void dfs2(int u)&#123; g[u][1]=a[u]; g[u][0]=0; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=son[u]&amp;&amp;v!=fa[u])&#123; dfs2(v); g[u][0]+=max(f[v][0],f[v][1]); g[u][1]+=f[v][0]; &#125; &#125; if (son[u]) dfs2(son[u]);&#125;struct node&#123; int l,r; matrix data;&#125;T[N&lt;&lt;2];void build(int u,int l,int r)&#123; T[u].l=l,T[u].r=r; if (l==r)&#123; T[u].data=matrix(g[fnd[l]][0],g[fnd[l]][1]); return; &#125; int mid=l+r&gt;&gt;1,v=u&lt;&lt;1; build(v,l,mid); build(v|1,mid+1,r); T[u].data=T[v].data*T[v|1].data; &#125;void modify(int u,int op)&#123; if (T[u].l==T[u].r)&#123; T[u].data=matrix(g[fnd[op]][0],g[fnd[op]][1]); return; &#125; int mid=T[u].l+T[u].r&gt;&gt;1,v=u&lt;&lt;1; if (op&lt;=mid) modify(v,op); else modify(v|1,op); T[u].data=T[v].data*T[v|1].data;&#125;matrix query(int u,int L,int R)&#123; if (L&lt;=T[u].l&amp;&amp;T[u].r&lt;=R) return T[u].data; int mid=T[u].l+T[u].r&gt;&gt;1,v=u&lt;&lt;1; if (R&lt;=mid) return query(v,L,R); if (L&gt;mid) return query(v|1,L,R); return query(v,L,R)*query(v|1,L,R);&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;n;i++)&#123; read(x),read(y); add(x,y),add(y,x); &#125; dfs(1); dfs1(1,1); dfs2(1); build(1,1,n); for (int i=1;i&lt;=m;i++)&#123; read(x),read(y); g[x][1]+=y-a[x]; a[x]=y; while (x)&#123; modify(1,dfn[x]); x=top[x]; matrix tmp=query(1,dfn[x],down[x]); int ff=fa[x]; g[ff][0]-=max(f[x][0],f[x][1]); g[ff][1]-=f[x][0]; f[x][0]=tmp.a[0][0]; f[x][1]=tmp.a[1][0]; g[ff][0]+=max(f[x][0],f[x][1]); g[ff][1]+=f[x][0]; x=fa[x]; &#125; printf("%d\n",max(f[1][0],f[1][1])); &#125; return 0;&#125; 例题二 动态dp【加强版】动态dp加强版 题目大意和例题一一样，只不过强制在线，并且$n,m\le 1e6$ 分析好像树剖跑不过去了，那么我们考虑用lct来代替树剖，复杂度确实是少了一个log，但是实际表现不理想，lct还是常数太大了。实际上我们用不到access,change_root,link,cut等操作，那我们是不是可以考虑构造一种类似的数据结构呢。全局平衡二叉树闪亮登场。 全局平衡二叉树概述与lct类似，把每条重链用一棵辅助树来维护，辅助树之间用虚边相连，每个节点维护自己所在重链辅助树的子树矩阵的乘积。如果会lct的话比较好理解。 建树我们定义每个点的权重$fs[u]=size[u]-size[fs[u]]$，对于每条重链，每次找到带权重心，左右递归建树即可，深度比我小的点在左儿子，深度比我大的点在右儿子。 复杂度证明可以参考 杨哲《SPOJ375 QTREE 解法的一些研究》 代码这里直接贴出全体的代码，建树的代码也包括在其中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (1000005)using namespace std;int n,x,y,tot,top,lastans,root,m;int a[N],tow[N&lt;&lt;1],son[N],nxt[N&lt;&lt;1],head[N],size[N],fs[N],fa[N],Fa[N],st[N],ch[N][2]; bool kill[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; tow[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void dfs(int u)&#123; size[u]=1; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u])&#123; fa[v]=u; dfs(v); size[u]+=size[v]; if (size[v]&gt;size[son[u]]) son[u]=v; &#125; &#125; fs[u]=size[u]-size[son[u]];&#125;struct matrix&#123; int a[2][2]; inline matrix()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=-1e9;&#125; inline matrix operator * (const matrix &amp;t) const&#123; matrix ret; for (int i=0;i&lt;=1;i++)&#123; for (int j=0;j&lt;=1;j++)&#123; ret.a[i][j]=max(a[i][0]+t.a[0][j],a[i][1]+t.a[1][j]); &#125; &#125; return ret; &#125; inline int mx()&#123; return max(max(a[0][0],a[1][0]),max(a[0][1],a[1][1])); &#125; inline void add(int x,int y)&#123; a[0][0]+=x,a[0][1]+=x,a[1][0]+=y; &#125;&#125;T[N],sum[N];void update(int u,int f)&#123; Fa[u]=f; kill[u]=1; T[f].add(sum[u].mx(),max(sum[u].a[0][0],sum[u].a[0][1]));&#125;void pushup(int u)&#123; sum[u]=sum[ch[u][0]]*T[u]*sum[ch[u][1]];&#125;int sbuild(int l,int r)&#123; if (l&gt;r) return 0; int tt=0,tmp=0; for (int i=l;i&lt;=r;i++) tt+=fs[st[i]]; for (int i=l;i&lt;=r;i++)&#123; tmp+=fs[st[i]]; if (tmp&gt;=(tt&gt;&gt;1))&#123; Fa[ch[st[i]][0]=sbuild(l,i-1)]=st[i]; Fa[ch[st[i]][1]=sbuild(i+1,r)]=st[i]; pushup(st[i]); return st[i]; &#125; &#125;&#125;int build(int u)&#123; for (int i=u;i;i=son[i])&#123; for (int p=head[i];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[i]&amp;&amp;v!=son[i])&#123; int kk=build(v); update(kk,i); &#125; &#125; &#125; top=0; for (int i=u;i;i=son[i]) st[++top]=i; return sbuild(1,top);&#125;void modify(int u,int data)&#123; T[u].a[1][0]+=data-a[u]; a[u]=data; while (u)&#123; if (kill[u])&#123; int t1=sum[u].mx(),t2=max(sum[u].a[0][0],sum[u].a[0][1]); pushup(u); T[Fa[u]].add(sum[u].mx()-t1,max(sum[u].a[0][0],sum[u].a[0][1])-t2); &#125; else&#123; pushup(u); &#125; u=Fa[u]; &#125;&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=n;i++) read(a[i]); T[0].a[0][0]=T[0].a[1][1]=0; sum[0].a[0][0]=sum[0].a[1][1]=0; for (int i=1;i&lt;=n;i++)&#123; T[i].a[1][0]=a[i]; T[i].a[0][0]=T[i].a[0][1]=0; &#125; for (int i=1;i&lt;n;i++)&#123; read(x),read(y); add(x,y); add(y,x); &#125; dfs(1); root=build(1); while (m--)&#123; read(x),read(y); modify(x,y); lastans=sum[root].mx(); printf("%d\n",lastans); &#125; return 0;&#125; 例题三 洪水Bzoj 4712 题目大意给定一颗n个点的树，每个点有点权。给m次操作，操作分成两类。(1)修改操作，修改一个点的点权(2)询问操作，对于一个节点，删除若干个点，使得询问的点与其子树中所有叶子均不连通，回答删除点的最小权值和$n,m \le 2e5$ 分析我们与例题一类似考虑，先考虑不带修改的情况。以$f[u]$表示使得u与其子树中所有叶子节点不连通的最小删除点权和。我们以$u\to v$表示v是u的字节点转移$f[u]=Min(a[u],\sum_{u\to v}f[v])$以$son[u]$表示u的重儿子。$f[u]=Min(a[u],f[son[v]]+\sum_{u\to v,v\ne son[u]}f[v])$令$g[u]=\sum_{u\to v,v\ne son[u]}f[v]$与例题一一样重新定义一下矩阵乘法，加法变为取max，乘法变为加法那么有 \left[ \begin {matrix} 0&0\\a[u]&g[u] \end {matrix} \right] \left[ \begin {matrix} 0\\f[son[u]] \end {matrix} \right] = \left[ \begin {matrix} 0\\f[u] \end {matrix} \right]博主手推，可能不是很优秀剩下的就和例题一一样了。但是要注意一个问题，询问的时候还需要查询每个几点的f值，并不是只有根节点的。对于一个节点的dp值，应该是这条重链上所有深度大于等于他的矩阵的乘积，(当我们查询根节点的时候，一定是整颗子树)，由于全局平衡二叉树的深度满足二叉查找树，所以我们在每次向上跳的过程中，如果我是从左儿子上去的，那么要把我父亲及父亲的整个右子树都乘上来，如果从右儿子上去则不用乘。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define int LL#define N (200005)using namespace std;int n,x,y,tot,m,root,top;int tow[N&lt;&lt;1],head[N],nxt[N&lt;&lt;1],size[N],fs[N],son[N],fa[N],Fa[N],st[N],ch[N][2],a[N];bool kill[N],leaf[N];char c[10];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline void add(int x,int y)&#123; tow[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;struct matrix&#123; int a[2][2]; inline matrix()&#123;memset(a,0,sizeof(a));&#125; inline matrix operator *(const matrix &amp;t) const&#123; matrix ret; for (int i=0;i&lt;=1;i++)&#123; for (int j=0;j&lt;=1;j++)&#123; ret.a[i][j]=min(a[i][0]+t.a[0][j],a[i][1]+t.a[1][j]); &#125; &#125; return ret; &#125; inline int f()&#123; return min(a[1][0],a[1][1]); &#125; inline void pri()&#123; printf("%d %d\n%d %d\n\n",a[0][0],a[0][1],a[1][0],a[1][1]); &#125;&#125;T[N],sum[N],sum1[N];void dfs(int u)&#123; size[u]=1; leaf[u]=1; for (int p=head[u];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[u])&#123; fa[v]=u; leaf[u]=0; dfs(v); size[u]+=size[v]; if (size[v]&gt;size[son[u]]) son[u]=v; &#125; &#125; fs[u]=size[u]-size[son[u]];&#125;void update(int u,int f)&#123; Fa[u]=f; T[f].a[1][1]+=sum[u].f(); kill[u]=1;&#125;void pushup(int u)&#123; sum[u]=sum[ch[u][0]]*T[u]*sum[ch[u][1]]; sum1[u]=T[u]*sum[ch[u][1]];&#125;int sbuild(int l,int r)&#123; if (l&gt;r) return 0; int tt=0,tmp=0; for (int i=l;i&lt;=r;i++) tt+=fs[st[i]]; for (int i=l;i&lt;=r;i++)&#123; tmp+=fs[st[i]]; if (tmp&gt;=(tt&gt;&gt;1))&#123; Fa[ch[st[i]][0]=sbuild(l,i-1)]=st[i]; Fa[ch[st[i]][1]=sbuild(i+1,r)]=st[i]; pushup(st[i]); return st[i]; &#125; &#125;&#125;int build(int u)&#123; for (int i=u;i;i=son[i])&#123; for (int p=head[i];p;p=nxt[p])&#123; int v=tow[p]; if (v!=fa[i]&amp;&amp;v!=son[i]) update(build(v),i); &#125; &#125; top=0; for (int i=u;i;i=son[i])&#123; st[++top]=i; &#125; return sbuild(1,top);&#125;void modify(int x,int y)&#123; T[x].a[1][0]+=y; a[x]+=y; while (x)&#123; if (kill[x])&#123; T[Fa[x]].a[1][1]-=sum[x].f(); pushup(x); T[Fa[x]].a[1][1]+=sum[x].f(); &#125; else pushup(x); x=Fa[x]; &#125;&#125;signed main()&#123; read(n); for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;n;i++)&#123; read(x),read(y); add(x,y); add(y,x); &#125; sum[0].a[0][1]=sum[0].a[1][0]=1e15; for (int i=1;i&lt;=n;i++) T[i].a[1][0]=a[i]; dfs(1); for (int i=1;i&lt;=n;i++)&#123; if (leaf[i]) T[i].a[1][1]=1e15; &#125; root=build(1); //for (int i=1;i&lt;=n;i++) T[i].pri(); //for (int i=1;i&lt;=n;i++) sum[i].pri(); read(m); while (m--)&#123; scanf("%s",c); if (c[0]=='Q')&#123; read(x); matrix ret=sum1[x]; while (!kill[x]&amp;&amp;x)&#123; if (ch[Fa[x]][0]==x) ret=ret*sum1[Fa[x]]; x=Fa[x]; &#125; printf("%lld\n",ret.f()); &#125; else&#123; read(x),read(y); modify(x,y); &#125; &#125; return 0;&#125; 例题四 [SDOI2017]切树游戏Luogu 3781 [SDOI2017]切树游戏 链接txc大爷的博客写的非常的好 结语动态dp的套路实际上都一样。核心内容就在于先推出不带修改时的dp方程，再将dp方程中重儿子的信息分离出来，用矩阵来表示转移。树链剖分后，重儿子的信息用线段树维护，轻儿子的信息暴力修改即可，由于树剖的优秀性质，跳上去的过程中最多暴力修改log次，复杂度就是对的，再利用全局平衡二叉树可以使复杂度更优。以上就是博主对动态dp的个人理解，如果有写的不对的地方，欢迎在评论中指出，感激不尽。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>动态dp</tag>
        <tag>全局平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF 1096] 题目分析]]></title>
    <url>%2F2018%2F12%2F29%2FCF-1096-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[链接Educational Codeforces Round 57 A由于题目保证有解，所以直接输出(l,2*l)就行了。12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int T,x,y; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(T); while (T--)&#123; read(x),read(y); printf("%d %d\n",x,2*x); &#125; return 0;&#125; B由于删除的是一个子串，所以最后留下的一定是个前缀或者后缀，那么我们就先暴力算出前缀的前多少位一样，后缀的最后多少位是一样的，设为a1和a2。由于题目保证整个串中至少出现两种字符，所以$a1+a2$一定$\le n$再看一下整个串的第一位和最后一位是否一样，如果相等，那么答案就是$(a1+1)*(a2+1)+1$否则输出$a1+a2+1$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (200005)using namespace std;int n,a1,a2;char s[N],pp;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(n); scanf("%s",s+1); pp=s[1]; a1=1; for (int i=2;i&lt;=n;i++)&#123; if (s[i]==pp) a1++; else break; &#125; for (int i=n;i&gt;=1;i--)&#123; if (s[i]==s[n]) a2++; else break; &#125; if (s[n]==pp)&#123; printf("%d",1ll*(a1+1)*(a2+1)%998244353); &#125; else&#123; printf("%d",a1+a2+1); &#125; return 0;&#125; C由于数据范围较小，我们考虑直接枚举正i边形是否可行。判断的话要根据两个条件,(1) $n*i%180==0$，我要是这个i边形内最小角的倍数(2) $n*i&lt;=(i-2)*180$，不能大于这个正i边形的最大内角123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int T,n; template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int gcd(int a,int b)&#123; while (a%b!=0)&#123; int tmp=b; b=a%b; a=tmp; &#125; return b;&#125;int main()&#123; read(T); while (T--)&#123; read(n); bool flag=0; for (int i=3;i&lt;=360;i++)&#123; if (n*i%180==0&amp;&amp;n*i&lt;=(i-2)*180)&#123; flag=1; printf("%d\n",i); break; &#125; &#125; if (!flag) puts("-1"); &#125; return 0;&#125; D考虑直接dp，f[i][j]表示到了第i个字符，hard这个结构只拥有前j个字符的最小代价，显然j的范围是$[0,3]$。转移的话看下第i个是不是”h”,”a”,”r”,”d”中的一个，如果是的话要花这个代价删除，直接看代码吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n; int a[N];LL f[N][5];char c[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int main()&#123; read(n); scanf("%s",c+1); for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;=n;i++)&#123; f[i][0]=f[i-1][0]; for (int j=1;j&lt;=3;j++) f[i][j]=min(f[i-1][j],f[i][j-1]); if (c[i]=='h') f[i][0]=f[i-1][0]+a[i]; else if (c[i]=='a') f[i][1]=f[i-1][1]+a[i]; else if (c[i]=='r') f[i][2]=f[i-1][2]+a[i]; else if (c[i]=='d') f[i][3]=f[i-1][3]+a[i]; //printf("%lld %lld %lld %lld\n",f[i][0],f[i][1],f[i][2],f[i][3]); &#125; LL minn=1e18; for (int j=0;j&lt;=3;j++) minn=min(minn,f[n][j]); printf("%lld",minn); return 0;&#125; E考场上没来得及看，待更 F由于期望的线性性，我们可以把整个期望的贡献分成三类，-1对-1，其他数字与其他数字，-1与其他数字。对于第一类贡献，令$f[i]$表示$[1,i]$的排列，逆序对数量的期望，考虑加入第i+1个数，放在最前面会产生i的贡献，向后移一位贡献-1，一共有i+1个位置可以放，分别能产生i,i-1,i-2…0的贡献，所以$f[i+1]=f[i]+\frac{(i+1)*i}{2*(i+1)}$，化简为通项式可得$f[i]=\frac{i*(i-1)}{4}$对于第二类贡献，直接树状数组求逆序对可得。对于第三类贡献，我们实际上就是考虑每个-1填每个数贡献的和，注意这里的贡献不能直接加。设-1的个数为tot，我们确定了这一位，贡献为x,剩下(tot-1)位不管怎么取对贡献没有影响，所以$x*((tot-1)!)$是最后的贡献，再除以$tot!$就是期望，即$\frac{x}{tot}$。但是这个贡献并不好算，我们考虑每个已经确定的数对-1的贡献，显然是我前面-1的个数乘上比我大的没取的数的个数，加上我后面-1的个数乘上比我小的没取的数的个数，把每一位的这个贡献sigma起来，乘以一个总-1数tot的逆元加到最后答案里就好了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define int long long#define N (200005)using namespace std;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int n,tot,ans,jc=1,res,inv;int a[N],T[N],sum[N];bool vis[N];const int P=998244353;inline void add(int x)&#123; for (int i=x;i&lt;=n;i+=i&amp;-i) T[i]++;&#125;inline int query(int x)&#123; int ret=0; for (int i=x;i;i-=i&amp;-i) ret+=T[i]; return ret; &#125;int ksm(int a,int b)&#123; if (b==0) return 1; int ret=1; while (b&gt;1)&#123; if (b&amp;1) ret=1ll*ret*a%P; b&gt;&gt;=1; a=1ll*a*a%P; &#125; return 1ll*a*ret%P;&#125;signed main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i]); if (a[i]==-1) tot++,jc=1ll*jc*tot%P; else vis[a[i]]=1; &#125; ans=1ll*tot*(tot-1)%P*ksm(4,P-2)%P; res=tot; inv=ksm(tot,P-2); for (int i=n;i&gt;=1;i--)&#123; if (a[i]!=-1) ans=(ans+query(a[i]-1))%P,add(a[i]); &#125; for (int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]; if (!vis[i]) sum[i]++; &#125; for (int i=1;i&lt;=n;i++)&#123; if (a[i]==-1) res--; else&#123; ans=(ans+(1ll*sum[a[i]]*res%P+1ll*(tot-sum[a[i]])*(tot-res)%P)%P*inv%P)%P; &#125; &#125; printf("%lld",ans); return 0;&#125; G第一感是dp，以f[i][j]表示已经确定了前i个数，前一半与后一半的差为j的方案数，但是这个差值可能会非常大，这个状态存不下。考虑生成函数。例如能去0,2,3,5,9，我们就用多项式$x^0+x^2+x^3+x^5+x^9$来表示，令这个多项式的n/2次幂为f，那么f中$x^k$的系数就可以表示组成k的方案数了。至于多项式的幂次可以不用分治+NTT考虑NTT第一步的本质，就是把系数表达式转化成点值表达式。众所周知点值是可以直接乘的，那么直接把NTT过的点值快速幂后NTT回来就行了。最后的答案就是每一项系数的平方的和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (6000005)using namespace std;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;const int P=998244353;int n,k,x,ans,lim;int f[N],R[N],b[N];int ksm(int a,int b)&#123; int ret=1; while (b&gt;1)&#123; if (b&amp;1) ret=1ll*ret*a%P; b&gt;&gt;=1; a=1ll*a*a%P; &#125; return 1ll*ret*a%P;&#125;inline void NTT(int *f,int G)&#123; for (int i=0;i&lt;lim;i++)&#123; if (i&gt;R[i]) swap(f[i],f[R[i]]); &#125; for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; int w0=ksm(G,(P-1)/(i&lt;&lt;1)); for (int j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; int w=1; for (int k=j;k&lt;j+i;k++)&#123; int t=1ll*f[k+i]*w%P; f[k+i]=(f[k]-t+P)%P; f[k]=(f[k]+t)%P; w=1ll*w*w0%P; &#125; &#125; &#125;&#125;int main()&#123; read(n),read(k); lim=4194304; for (int i=0;i&lt;lim;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*lim&gt;&gt;1); for (int i=1;i&lt;=k;i++)&#123; read(x); f[x]=1; &#125; NTT(f,3); for (int i=0;i&lt;lim;i++)&#123; b[i]=ksm(f[i],n/2); &#125; NTT(b,ksm(3,P-2)); int inv=ksm(lim,P-2); for (int i=0;i&lt;lim;i++) b[i]=1ll*b[i]*inv%P; for (int i=0;i&lt;lim;i++)&#123; ans=(ans+1ll*b[i]*b[i]%P)%P; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>CF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 6433]「PKUSC2018」最大前缀和]]></title>
    <url>%2F2018%2F12%2F28%2FLOJ-6433-%E3%80%8CPKUSC2018%E3%80%8D%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 6433 前言发现PKU好喜欢出概率期望dp啊，SCD1T2也是道概率期望dp。 做法仔细观察一下最大前缀和的性质，令最大前缀和最后一个数是第i位，可以发现$[1,i]$这一段所有的后缀和都为正，(否则你减掉这一段显然可以得到一个更大的)，$[i+1,n]$这一段的前缀和都非正。考虑状压dp，以$f[i]$表示选的数的集合是i，这个状态所有后缀和均为正的方案数，$g[i]$表示选的数的集合为i，这个状态所有前缀和均不正的方案数。两个的转移是类似的，f可以看做是前缀和，反正首尾倒过来就边后缀和了。枚举新加入一个数放在最后，如果它与前面所有的和是正的，那么$f[i|(1&lt;&lt;j-1)]+=f[i]$，否则$g[i|(1&lt;&lt;j-1)]+=g[i]$最后枚举最大前缀和的集合，$ans+=sum[i]*f[i]*g[(1&lt;&lt;n)-1-i]$. 交上去发现wa了，再仔细读一遍题目，发现最大前缀和不能为空，也就是如果每一段前缀和都是负的，我们也要选一段最大的，而不是啥都不选。而我们上面的dp显然我发处理这种情况，因为f都是0。而这种情况的最大前缀和也有非常好的性质，除了所有加起来是负的，其他所有的后缀也都是正的。我们只要在dp一个f1即可，$f1[i]$表示选的数的集合是i，这个状态出整个串之外的所有后缀和均为正的方案数。转移也很简单，枚举一个新加入的数放在最后，如果它与前面所有的和是负的，那么$f1[i|(1&lt;&lt;j-1)]+=f[i]$即可。最后统计答案的时候，如果f[i]为0，把f[i]改成f1[i]即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,ans; const int P=998244353;int f[1&lt;&lt;20],g[1&lt;&lt;20],sum[1&lt;&lt;20],a[N],f1[1&lt;&lt;20];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b); &#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=0;i&lt;(1&lt;&lt;n);i++)&#123; for (int j=1;j&lt;=n;j++)&#123; if ((1&lt;&lt;j-1)&amp;i) sum[i]+=a[j]; &#125; &#125; f[0]=1; g[0]=1; for (int i=0;i&lt;(1&lt;&lt;n);i++)&#123; for (int j=1;j&lt;=n;j++)&#123; if (!((i&gt;&gt;j-1)&amp;1))&#123; int tow=i|(1&lt;&lt;j-1); if (sum[tow]&gt;0) f[tow]=Inc(f[tow],f[i]); else g[tow]=Inc(g[tow],g[i]),f1[tow]=Inc(f1[tow],f[i]); &#125; &#125; &#125; for (int i=0;i&lt;(1&lt;&lt;n);i++)&#123; if (f[i]==0) ans=Inc(ans,1ll*(sum[i]+P)*f1[i]%P*g[(1&lt;&lt;n)-1-i]%P); else ans=Inc(ans,1ll*sum[i]*f[i]%P*g[(1&lt;&lt;n)-1-i]%P); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 2540]「PKUWC2018」随机算法]]></title>
    <url>%2F2018%2F12%2F27%2FLOJ-2540-%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 2540 前言PKUWC d2t1，还是比较清新的。 做法先看一眼数据范围，$n \le20$，那应该是个状压dp了。为了方便说明，以直接覆盖来称那些我选的点，间接覆盖来称那些由于和直接覆盖的点相连，而不能选的点，被覆盖的点就是这两个点集的并。首先先想到的自然是以$f[i],g[i]$分别表示目前被覆盖的点的状态为i时的最大独立集的大小和方案数。先预处理选每个点会导致哪些点被间接覆盖，显然是与我直接相连的点，而我自己是直接覆盖。考虑转移，枚举一个未被覆盖的点，更新一下f和g。最后除以阶乘。 但是这样会有问题，以样例来说，3 1 2 与 3 2 1被当成了同一种状态，因为你并没有枚举间接覆盖点2在什么时候选。所以我们用$f[i][j]$,$g[i][j]$来表示所有被覆盖的点集为i，被间接覆盖的点的点集为j。但是这样复杂度显然爆了。事实上所有被间接覆盖的点本质上都是一样的，所以我们并不需要知道是哪些，而只要知道有几个就行了。如果一个点原先是被间接覆盖，我选他，相当于只把他这个点变成直接覆盖，而不把与他相连的点视为间接覆盖，因为事实上我并没有把它加入独立集，只不过相当于是在选择序列的最后把它加入。用$f[i][j]$表示已经选了i个点，被覆盖的点集为j的最大独立集大小,$g[i][j]$表示方案数。对于(i,j)统计出j中有多少个点已经被覆盖了，减去i就是被间接覆盖的点的个数了。转移就分为取未被覆盖点还是间接覆盖点就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,m,x,y,jc; int kk[N],f[21][1&lt;&lt;20],g[21][1&lt;&lt;20];const int P=998244353;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int ksm(int a,int b)&#123; int ret=1; while (b&gt;1)&#123; if (b&amp;1) ret=1ll*ret*a%P; b&gt;&gt;=1; a=1ll*a*a%P; &#125; return 1ll*ret*a%P;&#125;int main()&#123; read(n),read(m); jc=1; for (int i=1;i&lt;=n;i++) kk[i]=(1&lt;&lt;i-1),jc=1ll*jc*i%P; for (int i=1;i&lt;=m;i++)&#123; read(x),read(y); kk[x]|=(1&lt;&lt;y-1); kk[y]|=(1&lt;&lt;x-1); &#125; g[0][0]=1; f[0][0]=0; for (int i=1;i&lt;=n;i++)&#123; for (int zt=0;zt&lt;(1&lt;&lt;n);zt++)&#123; if (!g[i-1][zt]) continue; int tt=0; for (int j=1;j&lt;=n;j++)&#123; if ((zt&gt;&gt;j-1)&amp;1) tt++; &#125; for (int j=1;j&lt;=n;j++)&#123; if (!((zt&gt;&gt;j-1)&amp;1))&#123; int tow=zt|kk[j]; if (f[i][tow]&lt;f[i-1][zt]+1)&#123; f[i][tow]=f[i-1][zt]+1; g[i][tow]=g[i-1][zt]; &#125; else if (f[i][tow]==f[i-1][zt]+1)&#123; g[i][tow]=Inc(g[i][tow],g[i-1][zt]); &#125; &#125; &#125; if (tt-i+1&gt;0)&#123; if (f[i-1][zt]&gt;f[i][zt])&#123; f[i][zt]=f[i-1][zt]; g[i][zt]=1ll*g[i-1][zt]*(tt-i+1)%P; &#125; else if (f[i-1][zt]==f[i][zt])&#123; g[i][zt]=Inc(g[i][zt],1ll*g[i-1][zt]*(tt-i+1)%P); &#125; &#125; &#125; //for (int zt=0;zt&lt;(1&lt;&lt;n);zt++)&#123; // printf("%d %d\n",f[i][zt],g[i][zt]); //&#125; // puts(""); &#125; printf("%lld",1ll*g[n][(1&lt;&lt;n)-1]*ksm(jc,P-2)%P); return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LOJ 2538]「PKUWC2018」Slay the Spire]]></title>
    <url>%2F2018%2F12%2F26%2FLOJ-2538-%E3%80%8CPKUWC2018%E3%80%8DSlay-the-Spire%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 2358 前言既然要去PKUWC，当然要做做去年的题看看自己水平啦。 做法首先要想到一个结论：如果有$\ge k-1$张翻倍牌的话，一定会先打掉最大的k-1张翻倍牌，然后再打一张点数最大的攻击牌，由于每张翻倍牌至少$*=2$，所以这个结论应该是显然的吧。再观察一下ans后面乘的那个式子，实际上就是C(2n,m)，相当于把求期望变成了求所有方案的和。（如果他不乘的话你就自己除掉就行了，没什么影响）既然是要求总和，那么getf(i,j)表示我从n张翻倍牌中选i张，这i张中前j大的乘积，再sigma起来。getg(i,j)表示我从n张攻击牌中选i张，这i张中前j大的加和，再sigma起来。 我们考虑枚举取i张翻倍牌，分情况讨论，结合上面的结论就可以得到下面所有代码中的Inc函数，表示把两个加起来对p取模。C则表示组合数。123456789for (int i=0;i&lt;=min(m,n);i++)&#123; if (m-i&gt;n) continue; if (i&lt;k)&#123; ans=Inc(ans,1ll*getf(i,i)*getg(m-i,k-i)%P); &#125; else&#123; ans=Inc(ans,1ll*getf(i,k-1)*getg(m-i,1)%P); &#125;&#125; 这里应该没问题吧。那么我们接下来考虑如何getf和getg.先说getf吧，先把a数组排序，使翻倍牌的大小递减。预处理f数组,f[i][j]表示前i张牌取j张，所得成绩的sigma，应该是个简单dp吧12345f[0][0]=1;for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) f[i][j]=Inc(f[i-1][j],1ll*f[i-1][j-1]*a[i]%P); f[i][0]=f[i-1][0];&#125; 然后我们枚举第j大的取的是第几张翻倍牌，前面的贡献可以从f中导出来，后面是个组合数博主语言能力有限，还是代码比较好理解。12345678int getf(int x,int y)&#123; if (y==0) return C[n][x]; int ret=0; for (int i=y;i&lt;=n;i++)&#123; ret=Inc(ret,1ll*f[i-1][y-1]*a[i]%P*C[n-i][x-y]%P); &#125; return ret;&#125; getg也是一样123456789101112g[0][0]=0;for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) g[i][j]=Inc(g[i-1][j],Inc(g[i-1][j-1],1ll*C[i-1][j-1]*b[i]%P)); g[i][0]=g[i-1][0];&#125;int getg(int x,int y)&#123; int ret=0; for (int i=y;i&lt;=n;i++)&#123; ret=Inc(ret,1ll*Inc(g[i-1][y-1],1ll*b[i]*C[i-1][y-1]%P)*C[n-i][x-y]%P); &#125; return ret;&#125; 代码把上面每一步拼在一起就好了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (3005)using namespace std;int T,n,m,k,ans; int g[N][N],f[N][N],C[N][N],a[N],b[N];const int P=998244353;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline bool cmp(int a,int b)&#123; return a&gt;b;&#125;int Inc(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int getf(int x,int y)&#123; if (y==0) return C[n][x]; int ret=0; for (int i=y;i&lt;=n;i++)&#123; ret=Inc(ret,1ll*f[i-1][y-1]*a[i]%P*C[n-i][x-y]%P); &#125; return ret;&#125;int getg(int x,int y)&#123; int ret=0; for (int i=y;i&lt;=n;i++)&#123; ret=Inc(ret,1ll*Inc(g[i-1][y-1],1ll*b[i]*C[i-1][y-1]%P)*C[n-i][x-y]%P); &#125; return ret;&#125;int main()&#123; read(T); C[0][0]=1; for (int i=1;i&lt;=3000;i++)&#123; for (int j=1;j&lt;=i;j++) C[i][j]=Inc(C[i-1][j-1],C[i-1][j]); C[i][0]=1; &#125; while (T--)&#123; read(n),read(m),read(k); for (int i=1;i&lt;=n;i++) read(a[i]); for (int i=1;i&lt;=n;i++) read(b[i]); sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); f[0][0]=1; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) f[i][j]=Inc(f[i-1][j],1ll*f[i-1][j-1]*a[i]%P); f[i][0]=f[i-1][0]; &#125; g[0][0]=0; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=i;j++) g[i][j]=Inc(g[i-1][j],Inc(g[i-1][j-1],1ll*C[i-1][j-1]*b[i]%P)); g[i][0]=g[i-1][0]; &#125; ans=0; for (int i=0;i&lt;=min(m,n);i++)&#123; if (m-i&gt;n) continue; if (i&lt;k)&#123; ans=Inc(ans,1ll*getf(i,i)*getg(m-i,k-i)%P); &#125; else&#123; ans=Inc(ans,1ll*getf(i,k-1)*getg(m-i,1)%P); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; 结语希望大家都能在WC中取得好成绩]]></content>
      <categories>
        <category>题目分析</category>
        <category>LOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中医大ACM校赛总结]]></title>
    <url>%2F2018%2F12%2F22%2F%E4%B8%AD%E5%8C%BB%E5%A4%A7ACM%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言人生中第一次到现场参加真正的ACM，收获颇丰。 正文考试还没开始前，好像说不能碰电脑，不过貌似整个机房都在敲板子，就先悄咪咪的敲了个快读和NTT。纸质体面发下来，lty大佬偷偷的看了眼T1，貌似就是个输出“Helle World!”。赶紧敲完复制好，就等考试开始去强一血了。考试一开始，急急忙忙点进T1，扫了一眼语言确实是C++11，赶紧提交，可惜花了5秒，一血只用了一秒。。手速还是不行啊。写完A后看了一眼D，发现只要求个最大值就好了，2分钟写完交了一发AC了，可惜又差了第一名13秒，错失一血。这时zck和lty两位大佬已经反复确认过B，只要三个特判就行了，于是我就稀里糊涂的听写了一段代码居然真的AC了。看了一眼榜大概第1，还是不错的。由于zck大佬前面已经把所有题看过一遍了，哪些题比较简单心中有数，F是一道简单DP，但是这场比赛的出题人比较鬼畜，总喜欢在最后改题意，险些没看见。I题就是个暴力，J题也是简单DP，奇偶分类下就好了。十分钟内连出F，I，J，仍占据着rank1的宝座。lty大佬说这个E是ZJOI2013K大数查询原题，还好我做过，写过博客，虽然是比较久之前的事了，但这个整体二分应该还是写的出来的。写下来还算顺利，可惜最后退树状数组的时候忘了特判操作类型了，还赔上20分钟罚时，错失了一血，有一点点可惜。出7题加只有1罚时还是全场rank1。这是看到H题有好多人出了，原来我们还害怕是不是有坑，事实证明直接两边BFS就好了，结果多组数据不小心dis忘清空了，又加了发罚时。最后是L这道模拟题，人多确实力量大啊，在我们三个共同努力调代码下，居然半个小时就把I写出来了，还是要多谢监考老师允许我向已经A了的大佬问题意省去了好多麻烦。出完9题还是rank1，但接下来的时间由于智商不够没能再想出别的题了，只能眼睁睁的看着自己从rank1掉到rank5。 结语两个大佬队友估计是嫌题目太垃圾了，让我一个人写了9题，假装没有抱大腿。没有拿到一血算是小小的遗憾了，不过总的来说，积累了宝贵的比赛经验还是蛮好的，rank5的成绩也不错。冬令营加油！lty大佬连国际象棋都吊打我]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 4311] 向量]]></title>
    <url>%2F2018%2F12%2F19%2FBZOJ-4311-%E5%90%91%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 2671 题目大意你需要维护一个向量集合，支持以下三种操作：(1) 插入一个新的向量(2) 删除一个原有向量(3) 给你一个向量a，查询目前向量集合中所有向量与a的点积的最大值 做法博主对于计算几何一窍不通，看到这个想到了KDtree。如果你要用KDtree做这题的话就非常简单，对于每个向量看成一个点，插入就KDtree中插入，删除也是。对于询问操作，我们像查询平面最近点对一样，写一个估价函数，计算KDtree上每个点所包含的矩形与查询点的最大点积，显然就是这个矩形的右上点，即x最大，y最大。其余的部分与查询平面最近点对无异。虽然复杂度不对，但是由于出题人可能并没想到会有毒瘤像我一样写KDtree，所以数据没卡，凭借一个不带重构的KDtree跑到了全站第五，实测加了重构反而变慢。写这篇博客可能只是想说有些题只要你有梦想，说不定暴力也能操标。贴上AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (200005)using namespace std;int n,op,x,y,tot,D,cnt,root,ax[N],ay[N];int h[N],q[2];LL ans;double alpha=0.6;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;struct node&#123; int l,r,d[2],mx[2],mn[2],knum,size; bool kill;&#125;T[N];inline bool cmp(int a,int b)&#123; return T[a].d[D]&lt;T[b].d[D];&#125;inline void update(int x)&#123; int l=T[x].l,r=T[x].r; T[x].size=T[l].size+T[r].size+1-T[x].kill; T[x].knum=T[l].knum+T[r].knum+T[x].kill; for (int i=0;i&lt;=1;i++)&#123; if (l) T[x].mx[i]=max(T[x].mx[i],T[l].mx[i]),T[x].mn[i]=min(T[x].mn[i],T[l].mn[i]); if (r) T[x].mx[i]=max(T[x].mx[i],T[r].mx[i]),T[x].mn[i]=min(T[x].mn[i],T[r].mn[i]); &#125;&#125;inline void build(int &amp;x,int l,int r,int k)&#123; if (l&gt;r) return; int mid=l+r&gt;&gt;1; D=k; nth_element(h+l,h+mid,h+r+1,cmp); x=h[mid]; T[x].size=1; T[x].kill=0; T[x].knum=0; for (int i=0;i&lt;=1;i++) T[x].mx[i]=T[x].mn[i]=T[x].d[i]; build(T[x].l,l,mid-1,k^1); build(T[x].r,mid+1,r,k^1); update(x);&#125;inline void erase(int &amp;x)&#123; if (!x) return; if (!T[x].kill) h[++tot]=x; erase(T[x].l),erase(T[x].r); x=0;&#125;inline void rebuild(int &amp;x,int k)&#123; tot=0; erase(x); build(x,1,tot,k); &#125;inline void insert(int &amp;x,int k)&#123; if (!x)&#123; x=++cnt; T[x].size=1; T[x].kill=0; T[x].knum=0; for (int i=0;i&lt;=1;i++) T[x].d[i]=T[x].mn[i]=T[x].mx[i]=q[i]; return; &#125; if (q[k]&lt;T[x].d[k]) insert(T[x].l,k^1); else insert(T[x].r,k^1); update(x); if (max(T[T[x].l].size,T[T[x].r].size)&gt;T[x].size*alpha||T[x].knum&gt;T[x].size*alpha) rebuild(x,k);//如果你想当全站第五的话把这句去掉就行了&#125;inline void del(int now,int x)&#123; if (now==x)&#123; T[x].kill=1; for (int i=0;i&lt;=1;i++) T[x].mx[i]=-1e9,T[x].mn[i]=1e9; update(x); return; &#125; int l=T[now].l; if (l&amp;&amp;T[l].mn[0]&lt;=q[0]&amp;&amp;q[0]&lt;=T[l].mx[0]&amp;&amp;T[l].mn[1]&lt;=q[1]&amp;&amp;q[1]&lt;=T[l].mx[1]) del(l,x); else del(T[now].r,x); update(now);&#125;LL calc(int x)&#123; if (!x) return -1e9; return 1ll*T[x].mx[0]*q[0]+1ll*T[x].mx[1]*q[1];&#125;inline void query(int now)&#123; if (!T[now].kill) ans=max(ans,1ll*T[now].d[0]*q[0]+1ll*T[now].d[1]*q[1]); LL al=calc(T[now].l),ar=calc(T[now].r); if (al&gt;ar)&#123; if (al&gt;ans) query(T[now].l); if (ar&gt;ans) query(T[now].r); &#125; else&#123; if (ar&gt;ans) query(T[now].r); if (al&gt;ans) query(T[now].l); &#125;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(op); if (op==1)&#123; read(q[0]),read(q[1]); insert(root,0); ax[cnt]=q[0],ay[cnt]=q[1]; &#125; else if (op==2)&#123; read(x); q[0]=ax[x],q[1]=ay[x]; del(root,x); &#125; else&#123; read(q[0]),read(q[1]); ans=0; query(root); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>KDtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈极角排序]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%B5%85%E8%B0%88%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言博主原先对于计算几何可谓是一窍不通，刚好做到两道极角排序的题，才刚刚有点感受到计算几何的魅(e)力(xin)。 极角排序所谓极角，指的就是以x轴正半轴为始边，逆时针转过的角，这个角的范围是$[0,2\pi]$。 极角排序的求法 利用atan2函数atan2(y,x)，表示(x,y)这个点与原点连线，这条线与x轴正半轴的夹角，这里的这个极角的范围是$[-\pi,\pi]$的，一二象限为正，三四象限为负。所以我们从小到大排完序后，实际上是第三象限$\to$第四象限$\to$第一象限$\to$第二象限。123456789101112struct node&#123; int x,y; double angle; inline bool operator &lt; (const node &amp;t) const&#123; return angle&lt;t.angle; &#125;&#125;for (int i=1;i&lt;=n;i++)&#123; read(a[i].x),read(a[i].y); a[i].angle=atan2(a[i].y,a[i].x);&#125;sort(a+1,a+n+1,cmp); 利用叉积来进行排序叉积已知两点坐标，通过叉积可以求得与原点所围成的三角形的有向面积。比如这两个点为a,b.$\frac{1}{2}*(a.x*b.y-a.y*b.x)$即为该三角形面积，那么为什么说是有向面积呢，如果这个值是正的，说明b位于a的正方向，即逆时针方向(当然，这个角度小于$\pi$)，反之，如果这个面积是负的，说明b位于a的负方向，即顺时针方向。那么我们就可以通过叉积来求极角了 1234567891011121314struct node&#123; int x,y; double angle; inline int operator * (const node &amp;t) const&#123; return a.x*b.y-a.y*b.x; &#125; &#125;inline bool cmp(node a,node b)&#123; return a*b&gt;0;&#125;for (int i=1;i&lt;=n;i++)&#123; read(a[i].x),read(a[i].y);&#125;sort(a+1,a+n+1,cmp); 比较两种求法的优劣第一种求法的常数比较优秀，但是精度有一定的损失。而叉积的求法常数较大，但是没有精度损失，可以根据情况的不同进行选择。 例题1.Luogu 2992题目大意：给你平面上n个点，保证任意两个点的连线都不经过原点，我们称所有包括原点的三角形为黄金三角形，问有多少个黄金三角形。$n\le100000$直接求黄金三角形好像有点难，我们考虑算出所有三角形的数量去减去非黄金三角形的数量。所有三角形的数量组合数算出。对于非黄金三角形，先确定一个点a，如果另外两个点均在我正方向$\pi$内，那么这三个点一定能构成一个非黄金三角形，如果不能理解的话可以画个图。我们先将所有的点极角排序，那么就可以一个指针扫过去知道有多少个点是在这个范围内的，组合数计算即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)using namespace std;int n,tot,r;LL ans;struct node&#123; int x,y; long double angle;&#125;a[N]; inline bool cmp(node a,node b)&#123; return a.angle&lt;b.angle;&#125;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;inline bool cj(int x,int y)&#123; return 1ll*a[x].x*a[y].y&gt;=1ll*a[x].y*a[y].x;//逆时针旋转小于pi &#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++) read(a[i].x),read(a[i].y),a[i].angle=atan2(a[i].y,a[i].x); sort(a+1,a+n+1,cmp); r=2; for (int i=1;i&lt;=n;i++)&#123; while (r!=i&amp;&amp;cj(i,r)) tot++,r=r%n+1; ans-=1ll*tot*(tot-1)/2; tot--; &#125; ans+=1ll*n*(n-1)*(n-2)/6; printf("%lld",ans); return 0;&#125; Luogu3476题目大意：给定平面上n个位于第一象限的点，求这些点所能组成的三角形的面积和。$0\le n\le3000$三个点不好处理，数据范围又是可以跑$n^2$的，考虑先枚举一个点，计算所有在它右边的点与它组成三角形的面积。先将所有点按照x坐标排序，如果x坐标相同则按y排序，枚举一个点，再将在我右侧的点极角排序。从小到大扫过去，那么叉积所得的值就一定是正的了，再将叉积展开，就可以得到一个后缀和的形式了，预处理一下即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (3005)using namespace std;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int n,tot;LL sumx,sumy,ans;struct node&#123; int x,y;&#125;a[N],q[N]; inline bool cmp(node a,node b)&#123; return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;inline bool cmp1(node a,node b)&#123; return 1ll*a.x*b.y-1ll*a.y*b.x&gt;0;&#125;int main()&#123; read(n); for (int i=1;i&lt;=n;i++)&#123; read(a[i].x),read(a[i].y); &#125; sort(a+1,a+n+1,cmp); for (int i=1;i&lt;=n;i++)&#123; tot=0; for (int j=i+1;j&lt;=n;j++)&#123; tot++; q[tot].x=a[j].x-a[i].x; q[tot].y=a[j].y-a[i].y; &#125; sort(q+1,q+tot+1,cmp1); sumx=0,sumy=0; for (int j=1;j&lt;=tot;j++) sumx+=q[j].x,sumy+=q[j].y; for (int j=1;j&lt;=tot;j++)&#123; sumx-=q[j].x,sumy-=q[j].y; ans+=sumy*q[j].x-sumx*q[j].y; &#125; &#125; printf("%lld.%lld",ans/2,(ans&amp;1)*5); return 0;&#125; 结语简单的讲解了一下极角排序，希望能够有所帮助。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 3589] 动态树]]></title>
    <url>%2F2018%2F12%2F09%2FBZOJ-3589-%E5%8A%A8%E6%80%81%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 3589 题目大意给你一棵树，有两种操作，第一种是子树权值加，第二种是给你不超过五条链，让你求这些链的并集的权值和，这些链都是某个节点到根的一段，点数和询问数均$\le 200000$ 做法首先这种求链的权值和的题目肯定是要树链剖分的，子树加应该也是基础操作了。那么怎么来求这5条链的交呢？去网上的题解看看大多都是LCA搞搞，细节可能会比较的多。博主这里提供一个别样的思路。我们树链剖分事实上就是把我们要求的那条链分解成不超过log段，dfn连续的区间，然后在线段树上查询对吧。那么我们这里对这五条链也一样处理，在线段树上做区间置，表示这几段的值是我要的。由于是区间置，所以就自动去重了。最后再查询一下就好了。具体实现的话可以看代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (200005)using namespace std;template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;int n,tot,cnt,x,y,now,q,op,k; int head[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],size[N],ss[N],maxx[N],top[N],dfn[N],fa[N],dep[N];inline void add(int x,int y)&#123; son[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void dfs1(int u)&#123; size[u]=1; int maxx=0; for (int p=head[u];p;p=nxt[p])&#123; int v=son[p]; if (v!=fa[u])&#123; fa[v]=u; dep[v]=dep[u]+1; dfs1(v); size[u]+=size[v]; if (size[v]&gt;maxx)&#123; maxx=size[v]; ss[u]=v; &#125; &#125; &#125;&#125;void dfs2(int u,int f)&#123; dfn[u]=++cnt; top[u]=f; if (ss[u])&#123; dfs2(ss[u],f); &#125; for (int p=head[u];p;p=nxt[p])&#123; int v=son[p]; if (v!=ss[u]&amp;&amp;v!=fa[u]) dfs2(v,v); &#125;&#125;struct node&#123; int l,r,lazy1,lazy2,sum,lazy;&#125;T[N&lt;&lt;2];void build(int u,int L,int R)&#123; T[u].l=L,T[u].r=R; if (L==R) return; int mid=L+R&gt;&gt;1,v=u&lt;&lt;1; build(v,L,mid); build(v|1,mid+1,R); &#125;void pushdown(int u)&#123; if (T[u].lazy)&#123; int v=u&lt;&lt;1,x=T[u].lazy; T[u].lazy=0; T[v].lazy+=x,T[v|1].lazy+=x; T[v].sum+=(T[v].r-T[v].l+1)*x; T[v|1].sum+=(T[v|1].r-T[v|1].l+1)*x; &#125;&#125;void add(int u,int L,int R,int data)&#123; if (L&lt;=T[u].l&amp;&amp;T[u].r&lt;=R)&#123; T[u].sum+=(T[u].r-T[u].l+1)*data; T[u].lazy+=data; return; &#125; pushdown(u); int mid=T[u].l+T[u].r&gt;&gt;1,v=u&lt;&lt;1; if (L&lt;=mid) add(v,L,R,data); if (R&gt;mid) add(v|1,L,R,data); T[u].sum=T[v].sum+T[v|1].sum;&#125;void change(int u,int L,int R)&#123; if (L&lt;=T[u].l&amp;&amp;T[u].r&lt;=R)&#123; T[u].lazy2=now; T[u].lazy1=now; return; &#125; T[u].lazy2=now; int mid=T[u].l+T[u].r&gt;&gt;1,v=u&lt;&lt;1; if (L&lt;=mid) change(v,L,R); if (R&gt;mid) change(v|1,L,R); &#125;int query(int u)&#123; //printf("%d %d %d\n",T[u].l,T[u].r,T[u].sum); if (T[u].lazy1==now)&#123; //printf("query %d %d %d\n",T[u].l,T[u].r,T[u].sum); return T[u].sum; &#125; pushdown(u); int v=u&lt;&lt;1,ret=0; if (T[v].lazy2==now) ret+=query(v); if (T[v|1].lazy2==now) ret+=query(v|1); return ret;&#125;void jump(int x,int y)&#123; while (top[x]!=top[y])&#123; change(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; change(1,dfn[y],dfn[x]);&#125; int main()&#123; read(n); for (int i=1;i&lt;n;i++)&#123; read(x),read(y); add(x,y),add(y,x); &#125; build(1,1,n); dfs1(1); dfs2(1,1); //for (int i=1;i&lt;=n;i++) printf("%d ",dfn[i]); //puts(""); read(q); while (q--)&#123; read(op); if (op==0)&#123; read(x),read(y); add(1,dfn[x],dfn[x]+size[x]-1,y); &#125; if (op==1)&#123; read(k); now++; for (int i=1;i&lt;=k;i++)&#123; read(x),read(y); if (dep[x]&lt;dep[y]) jump(y,x); else jump(x,y); &#125; int tt=query(1); if (tt&lt;0) tt+=(1&lt;&lt;31); printf("%d\n",tt); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu 3332] K大数查询]]></title>
    <url>%2F2018%2F11%2F29%2FLuogu-3332-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题目链接Luogu 3332 前言这道题真的是好题，写了好多遍，本篇博客讲解两种方法，整体二分和线段树套线段树的做法。 整体二分如果只有一个询问，那么我们对于这个询问二分一个答案mid，我们判断大于mid的数是否有询问的k个，遍历每一个修改，如果加入的这个数是大于mid的，说明会对这个k有影响，那么我们就用数据结构维护一个区间加，然后把它扔到q2队列里。如果加入的这个数小于mid，说明对目前二分的答案没有影响，就扔到q1队列里。最后数据结构区间查询看一下我询问的这个区间里有多少个数比我大，如果大于等于k，说明我mid还要增大，这时候所有q1队列里的修改都没有意义了，我们直接到q2里去做就行了，反之如果区间查询出来小于k，那么我就把mid减小，然后到q1队列里做，记得把数据结构初始化一下。那么如果多个询问呢，我们就多个询问一起二分答案，这就是整体二分。对于每一个询问，如果大于mid的数ans大于等于k，我们到分治到左边，然后把q[i].k-=ans，因为我们之后就不会让所有大于mid的修改影响这个询问了。否则就分治到右边做下去。 给同学讲了一遍，发现他理解不了，我觉得还可以再总结总结。 每一次divide，修改操作A分为两种，1.修改数大于mid 2.修改数小于mid询问操作B也分为两种，1.mid还需要变大的 2.mid还需要变小的我们发现A.1对于B.2的贡献我们再这次divide当中已经计算完毕了，只要B.2减掉就行了同样的，A.2对于B.1是没有贡献的，所以我们只要把A.1和B.1配对，A.2和B.2配对，然后分别递归下去就好了 整体二分的精髓在于每一次没有贡献的操作，或者贡献已知的操作，直接不要就行了，这样就保证了复杂度的正确性。 可能这样口述有点苍白，我们结合代码进行理解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define int long long#define INF (2139062143)#define N (50001)using namespace std;int n,m,cnt;int T1[N],T2[N],ans[N];inline void add(int x,int data)&#123; int add1=data,add2=data*x; for (int i=x;i&lt;=n;i+=i&amp;-i)&#123; T1[i]+=add1,T2[i]+=add2; &#125;&#125;inline int query(int x)&#123; int sum1=0,sum2=0; for (int i=x;i;i-=i&amp;-i)&#123; sum1+=T1[i],sum2+=T2[i]; &#125; return (x+1)*sum1-sum2;&#125;struct node&#123; int op,l,r,data,num;&#125;a[N],q1[N],q2[N];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;void divide(int head,int tail,int l,int r)&#123;//整体二分，表示我现在的操作队列为head..tail，包括修改和查询，我二分的左右端点是l,r if (head&gt;tail) return;//如果操作队列是空的就return if (l==r)&#123;//如果已经找到答案就把答案记录下来 for (int i=head;i&lt;=tail;i++)&#123; if (a[i].op==2)&#123; ans[a[i].num]=l; &#125; &#125; return; &#125; int len1=0,len2=0,mid=l+r&gt;&gt;1; for (int i=head;i&lt;=tail;i++)&#123;//顺序就行了，自动按时间线排序，在我后面的修改是不会对我产生影响的 if (a[i].op==1)&#123; if (a[i].data&lt;=mid) q1[++len1]=a[i];//这个表示加入左队列 else&#123; q2[++len2]=a[i]; add(a[i].l,1),add(a[i].r+1,-1);//如果这个修改对当前mid有影响，区间加 &#125; &#125; else&#123; int tmp=query(a[i].r)-query(a[i].l-1); //区间查询，比我大的数有tmp个，如果这个tmp&lt;我的data，说明我二分的答案还太大，我就压入左队列，然后我要把现在这些数的贡献减掉，因为我分治下去的时候右队列里的数的贡献就不会在考虑了，应该是整体二分的精髓所在了。 if (tmp&lt;a[i].data)&#123; a[i].data-=tmp; q1[++len1]=a[i]; &#125; else q2[++len2]=a[i]; &#125; &#125; for (int i=head;i&lt;=tail;i++)&#123; if (a[i].op==1&amp;&amp;a[i].data&gt;mid) add(a[i].l,-1),add(a[i].r+1,1);//直接memset清空就爆了 &#125; for (int i=1;i&lt;=len1;i++) a[head+i-1]=q1[i]; for (int i=1;i&lt;=len2;i++) a[head+len1+i-1]=q2[i]; divide(head,head+len1-1,l,mid); divide(head+len1,tail,mid+1,r); //分别递归左边和右边&#125;signed main()&#123; read(n),read(m); for (int i=1;i&lt;=m;i++)&#123; read(a[i].op); read(a[i].l),read(a[i].r),read(a[i].data); if (a[i].op==2)&#123; a[i].num=++cnt; &#125; &#125; divide(1,m,-50000,50000); for (int i=1;i&lt;=cnt;i++) printf("%lld\n",ans[i]); return 0;&#125; 复杂度分析一波。我们最多递归log层，每个修改每次只可能分在左队列或右队列，所以只会树状数组log次，所以复杂度为$log^2$同理，询问操作也是一样，所以中复杂度是$m*log(值域)*log(n)$第一个log为二分，第二个log为树状数组。 如果有什么没有看懂的，希望大家在评论中指出，博主尽量解答并改进，感激不尽。 树套树我使用的是权值线段树套线段树，如果外层区间为$[l,r]$，内层为$[a,b]$，则表示在$[a,b]$区间内，权值在$[l,r]$中的数有多少个。那么区间$[x,y]$插入k的话我们直接在每个包括k的权值区间中，内层线段树$[x,y]$区间加一下。查询$[a,b]$第k大的话，看一下右儿子$[a,b]$区间中的数是不是大于k个，如果是，则到右儿子查询，不然k-=ans，然后到做儿子中查询就行了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#define LL long long#define N (100001)using namespace std;int opt,l,r,x,y,K,n,m,cnt,L,R;int lson[N&lt;&lt;7],rson[N&lt;&lt;7],addv[N&lt;&lt;7],root[N&lt;&lt;2];LL sum[N&lt;&lt;7];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;void add(int &amp;u,int l,int r)&#123; if (!u) u=++cnt; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; sum[u]+=(r-l+1); addv[u]++; return; &#125; int mid=l+r&gt;&gt;1; if (L&lt;=mid) add(lson[u],l,mid); if (R&gt;mid) add(rson[u],mid+1,r); sum[u]=sum[lson[u]]+sum[rson[u]]+addv[u]*(r-l+1);&#125;void insert(int u,int l,int r)&#123; add(root[u],1,n); if (l==r) return; int mid=l+r&gt;&gt;1,v=u&lt;&lt;1; if (K&lt;=mid) insert(v,l,mid); else insert(v|1,mid+1,r);&#125;LL ask(int u,int l,int r)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return sum[u]; &#125; int mid=l+r&gt;&gt;1; LL ret=0; if (L&lt;=mid) ret+=ask(lson[u],l,mid); if (R&gt;mid) ret+=ask(rson[u],mid+1,r); ret+=(min(R,r)-max(l,L)+1)*addv[u]; return ret; &#125;int query(int u,int l,int r)&#123; if (l==r) return l; int mid=l+r&gt;&gt;1,v=u&lt;&lt;1; LL rsize=ask(root[v|1],1,n); if (K&lt;=rsize) return query(v|1,mid+1,r); else&#123; K-=rsize; return query(v,l,mid); &#125;&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=m;i++)&#123; read(opt),read(L),read(R),read(K); if (opt==1)&#123; insert(1,-50000,50000); &#125; else&#123; printf("%d\n",query(1,-50000,50000)); &#125; &#125; return 0;&#125; 这道题的树套树还是蛮好码的。]]></content>
      <categories>
        <category>题目分析</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1901] Dynamic Rankings]]></title>
    <url>%2F2018%2F11%2F29%2FBZOJ-1901-Dynamic-Rankings%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1901 前言首先不得不说某些博客名称写的是树状数组套主席树的人，实际上写的是树状数组套权值线段树，这种把权值线段树和主席树划等号的人，简直是误人子弟。主席树实际上是可持久化的权值线段树，他的核心思想是现在这个时刻的权值线段树要继承上个时刻的权值线段树，而这道题目中没有用到这种方法，这里必须要申明一下。当然也有一些神犇用的确实是树状数组套主席树，%%%% 题解我们的这个东西相当于解决一个区间查询，单点修改的问题。于是我们想到了树状数组，我们对于树状数组的每一个节点建一颗权值线段树，那么我们想得到一个区间的权值线段树的话，只要用树状数组得到前缀的权值线段树然后减一减就行了，然后修改的话，我们只要把包含这个点的权值线段树加一加减一减就行了，这个可以用树状数组处理。复杂度分析一波的话，每次查询和修改都会访问到log颗权值线段树，然后权值线段树查询第k大也是log的，所以总时间复杂度是两个log的，空间的话用动态开点实现，也是两个log的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define INF (2139062143)#define N (10005)using namespace std;int n,m,cnt,x,y,z,t1,t2;int a[N],q1[N],q2[N],root[N];int lson[N*32*14*2],rson[N*32*14],size[N*32*14];char c[11];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;void insert(int &amp;u,int l,int r,int op)&#123; if (!u) u=++cnt; size[u]++; if (l==r) return; int mid=l+r&gt;&gt;1; if (op&lt;=mid) insert(lson[u],l,mid,op); else insert(rson[u],mid+1,r,op); &#125;void del(int u,int l,int r,int op)&#123; size[u]--; if (l==r) return; int mid=l+r&gt;&gt;1; if (op&lt;=mid) del(lson[u],l,mid,op); else del(rson[u],mid+1,r,op);&#125; inline void add(int x,int data)&#123; for (int i=x;i&lt;=n;i+=i&amp;-i) insert(root[i],0,1e9,data);&#125;inline void change(int x,int data)&#123; for (int i=x;i&lt;=n;i+=i&amp;-i) insert(root[i],0,1e9,data),del(root[i],0,1e9,a[x]);&#125;int query(int l,int r,int k)&#123; if (l==r) return l; int lsize=0; for (int i=1;i&lt;=t1;i++) lsize+=size[lson[q1[i]]]; for (int i=1;i&lt;=t2;i++) lsize-=size[lson[q2[i]]]; int mid=l+r&gt;&gt;1; //printf("%d %d %d\n",l,mid,lsize); if (k&gt;lsize)&#123; for (int i=1;i&lt;=t1;i++) q1[i]=rson[q1[i]]; for (int i=1;i&lt;=t2;i++) q2[i]=rson[q2[i]]; return query(mid+1,r,k-lsize); &#125; else&#123; for (int i=1;i&lt;=t1;i++) q1[i]=lson[q1[i]]; for (int i=1;i&lt;=t2;i++) q2[i]=lson[q2[i]]; return query(l,mid,k); &#125;&#125;struct node&#123; int id,data;&#125;b[N&lt;&lt;1];int main()&#123; read(n),read(m); for (int i=1;i&lt;=n;i++)&#123; read(a[i]); add(i,a[i]); &#125; for (int i=1;i&lt;=m;i++)&#123; scanf("%s",c); if (c[0]=='Q')&#123; read(x),read(y),read(z); t1=0,t2=0; for (int j=y;j;j-=j&amp;-j) q1[++t1]=root[j]; for (int j=x-1;j;j-=j&amp;-j) q2[++t2]=root[j]; printf("%d\n",query(0,1e9,z)); &#125; if (c[0]=='C')&#123; read(x),read(z); change(x,z); a[x]=z; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRT学习笔记]]></title>
    <url>%2F2018%2F11%2F29%2FCRT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言CRT，中国剩余定理，用于求解同余方程。据说古代有个著名问题叫韩信点兵，数学化一下就是x ≡ 2(mod 3)x ≡ 3(mod 5)x ≡ 2(mod 7) 求解我们三个等式分开求解，最后加起来，那么如果x1是5和7的公倍数，后面加的时候就不会产生影响。由第一个等式我们得到，x1是5和7的公倍数，且%3==2。转化一下得到若a是5和7的公倍数，且%3==1，那么2a就是一个合法的x，余数的可乘性。那么要保证是5和7的公倍数，就$*35$，又要保证%3==1，那么再乘以35在%3意义下的逆元就行了，最后乘以2，所以x1=35$*({35}^{-1})*2$同理求出x2,x3,然后x1+x2+x3就是一个合法解，最小解的话模一下最小公倍数就可以了这其实就是中国剩余定理对于一组同余方程如果保证$m_1,m_2…m_k$ 两两互质, 且令P为$m_1,m_2…m_k$之积则有结论 x ≡ ($a_1*M_1*M_1^{-1}+a_2*M_2*M_2^{-1}+…+a_k*M_k*M_k^{-1}$)(mod P)其中$M_i$为$\frac{P}{m_i}$,$M_i^{-1}$即$M_i$在模$m_i$意义下的逆元($M_i*M_i^{-1}$≡1(mod $m_i$))原理就和前面举的例子一样，只不过扩展了一下。希望能对学习有帮助，谢谢。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 1483] 梦幻布丁]]></title>
    <url>%2F2018%2F11%2F29%2FBZOJ-1483-%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ 1483 题目大意有一个长为n的的数列，数列上每个点有个颜色，有m此操作，每次操作可以将一种颜色的所有点染成另一种颜色，或这查询当前有几段颜色。$n,m\le1000000$ 做法网上好多的做法都是链表合并，我感觉有点难写，这里提供一种不一样的思路，线段树合并，复杂度是一样的，都是一个log，但是代码复杂度应该会比较简单。我们对每个颜色建一棵线段树，线段树每个节点记录三个信息，size，ll，rr，分别表示这个颜色这段区间中的段数，左边是否顶到，右边是否顶到。update的时候，1size[u]=size[lson[u]+size[rson]-(rr[lson[u]&amp;&amp;ll[rson[u]) 应该可以理解吧。那么一开始的答案就是所有size[root[i]]的和。对于修改操作，我们先1ans-=size[root[x]]+size[root[y]] 然后我们把x的这棵线段树合并到y上面，因为底层的节点不会重复，所以我们先递归到底层，然后不断update上来就行了，这里的合并使用启发式合并，保证复杂度的正确性。最后ans在加上size[root[y]]就行了，然后记得把root[x]设为0。注意判一下x==y的情况就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#define LL long long#define N (100005)#define M (1000005)using namespace std;int n,m,cnt,ans,op,x,y;int a[N],tot[M],root[M],lson[N*21],rson[N*21],size[N*21];bool ll[N*21],rr[N*21];template &lt;typename T&gt; void read(T&amp;t) &#123; t=0; bool fl=true; char p=getchar(); while (!isdigit(p)) &#123; if (p=='-') fl=false; p=getchar(); &#125; do &#123; (t*=10)+=p-48;p=getchar(); &#125;while (isdigit(p)); if (!fl) t=-t;&#125;void update(int u)&#123; ll[u]=ll[lson[u]],rr[u]=rr[rson[u]]; size[u]=size[lson[u]]+size[rson[u]]-(rr[lson[u]]&amp;&amp;ll[rson[u]]);&#125;void insert(int &amp;u,int l,int r,int op)&#123; if (!u) u=++cnt; if (l==r)&#123; ll[u]=rr[u]=1; size[u]=1; return; &#125; int mid=l+r&gt;&gt;1; if (op&lt;=mid) insert(lson[u],l,mid,op); else insert(rson[u],mid+1,r,op); update(u);&#125;void merge(int &amp;x,int y)&#123; if (!x||!y)&#123; x|=y; return; &#125; merge(lson[x],lson[y]); merge(rson[x],rson[y]); update(x);&#125;int main()&#123; read(n),read(m); for (int i=1;i&lt;=n;i++)&#123; read(a[i]); tot[a[i]]++; insert(root[a[i]],1,n,i); &#125; for (int i=1;i&lt;=1000000;i++) ans+=size[root[i]]; while (m--)&#123; read(op); if (op==2)&#123; printf("%d\n",ans); &#125; if (op==1)&#123; read(x),read(y); if (x==y) continue; ans-=size[root[x]]+size[root[y]]; merge(root[y],root[x]); ans+=size[root[y]]; root[x]=0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller_Rabin&Pollard_Rho 学习笔记]]></title>
    <url>%2F2018%2F11%2F29%2FMiller-Rabin-Pollared-Rho%2F</url>
    <content type="text"><![CDATA[Miller_Rabin质数判断我们朴素的质数判断算法是枚举小于等于$\sqrt{n}$的数，判断是否都不能整除n，这样的复杂度是$\sqrt{n}$，那么当n的数量级达到$10^{18}$的时候就不够优越了。这时候我们的Millar_Rabin算法就闪亮登场了。我们的故事从费马小定理讲起，$a^{p-1}$≡1(mod p)，当p为质数的时候。在费马小定理被证明出来的很长一段时间内，人们都认为费马小定理的逆定理是正确的，即如果$2^{p-1}$≡1(mod p)，那么就认为p是个质数，但其实341就是一个反例，这种我们成为强伪素数的数可以把这种判定方法轻松卡掉。但是我们发现了这样一个事情，我们称为二次探测定理 如果$x^2≡1$(mod p)，那么也就是说$(x+1)(x-1)≡0$ (mod p)，又因为p是质数，所以$x+1$≡0(mod p)或者$x-1$≡0(mod p)，所以x mod p=1或者 x mod p=-1 那么我们有了二次探测定理，我们再来看341这个数。 $2^{340}$%341 == 1 $2^{170}$%341 == 1 $2^{85}$%341 == 32 这时候就出现问题了，我们就把341这个伪质数揪出来了。我们把质数的这个序列找出来发现一定是形如1,1…1,1,1,1,p-1这样子的，p-1之后可以为无序，我们设x要判断的数，d为x去掉所有2因子之后的结果。先判断$2^{d}$%x为多少，然后不断地把d*2，继续判断余数。只有出现这两种情况时我们认为x是质数1.序列全为12.序列出现了p-1我们结合代码来讲如何判断1234567for (int i=1;i&lt;=t;i++)&#123; LL d=x-1; while (!(d&amp;1)) d&gt;&gt;=1; LL s=ksm(q[i],d,x); while (s!=1&amp;&amp;s!=x-1&amp;&amp;d!=x-1) d&lt;&lt;=1,s=mul(s,s,x); if (s!=x-1&amp;&amp;!(d&amp;1)) return 0;//如果找到的是p-1则没事，如果找到的是1，(根据二次探测定理，1前面一定全是1）那么必须全为1。&#125; 但是这样判断并不一定完全正确，所以我们需要将2(上文中的底数)换成别的数，一般来说在long long 范围内，2，3，7，61就都够用了。 这是模板题 LOJ 143 Pollard_Rho为什么要把这两个放在一起讲呢，因为这两个算法的正确性都有那么一点瑕疵，可能算是某种相同点吧，而且Pollard_Rho中要用到Miller_Rabin。先贴出模板题吧，求$\phi(n)$，n&lt;=$10^{18}$如果直接暴力，也是根号的。那么我们随机一个数判断是否为n的因数，也不是很优，甚至劣于暴力。作者对于Pollard_Rho的复杂度证明也不是很精通，这里就讲一讲做法。每次有一个n，我们先用Miller_Rabin 判断他本身是不是质数，如果不是质数，我们先在0…n-1范围内随机一个种子seed，我们依靠这个seed来形成一个随机序列，假设这个随机序列的这一项为x，那么下一项为(x*x+seed)%n，我们每次判断这个随机序列的a,b两项做差，用这个差和n取gcd，然后进一步分解。看代码12345678910111213141516171819202122232425LL Nex(LL x,LL n)&#123; return (mul(x,x,n)+seed)%n;//mul为慢速乘，防止乘的时候爆long long&#125;void Pollard_Rho(LL n)&#123; if (n==1) return; if (Miller_Rubin(n))&#123;//这里计算phi m[n]++;//m是个map if (m[n]==1) ans=ans*(n-1); else ans=ans*n; return; &#125; while (1)&#123; seed=rand()*rand()%(n-1);//先随机一个seed LL a=rand()%(n-1),b=Nex(a,n); while (a!=b)&#123; LL kk=gcd(n,abs(a-b)); if (kk&gt;1)&#123; Pollard_Rho(kk); Pollard_Rho(n/kk); return; &#125; a=Nex(a,n),b=Nex(Nex(b,n),n);//这里很关键，b每次都比a多走一步，如果形成环的话，b势必会追上a，这种判环的方法最为好写，是floyd这个人发明的，注意，不是我们所熟知的那个3方的floyd。 &#125; &#125;&#125; 以上就是Pollard_Rho 的实现过程，希望对大家有所帮助，如果有写的不对或不好的地方，欢迎评论指正，谢谢。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>大数分解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ 3696] 化合物]]></title>
    <url>%2F2018%2F11%2F28%2FBZOJ-3696-%E5%8C%96%E5%90%88%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 3696 题目大意 介于这是一道权限题，先讲一下题意 有一棵根节点编号为1的数，给出每一个节点的父亲。 对于点对(x,y)，令他们的LCA为k，定义这对点对的A值为dis[x][k])^dis[y][k]，dis即为两点间的最短距离(边数)， 最后求出对于x=(1…n)，A值为x的点对的数量。 点数1e5，且题目保证最大的深度为500 前言看到这道题马上想到树形dp，但是冷静下来分析一下，发现复杂度不太对，写了一下发现跑的飞快，百度了一下这道题的题解，连hzwer大佬都说复杂度不会分析，不过在大佬的帮助下我得知了如何证明复杂度，这里想和大家分享一下。 正文最暴力的做法就是枚举两个点，算一下lca，两个深度异或一下加到答案里，复杂度$n^2*log$，这个应该都没问题，不细讲了。再一步想到枚举lca1234567891011121314void dfs(int u)&#123; f[u][0]=1; //我们以f[i][j]表示到i这个点距离为j的点的数量，当然指考虑在i下方的点，初始f[u][0]=1 for (int p=head[u];p;p=nxt[p])&#123; int v=son[p]; dfs(v); for (int d=0;d&lt;=maxdep[u];d++)&#123;//相当于枚举u之前的子树 for (int i=0;i&lt;=maxdep[v];i++)&#123;//枚举v中的点 ans[d^(i+1)]+=1ll*f[u][d]*f[v][i];//转移 &#125; &#125; for (int d=0;d&lt;=maxdep[v];d++) f[u][d+1]+=f[v][d];//将v这颗子树加进来 maxdep[u]=max(maxdep[u],maxdep[v]+1);//更新一下最大深度 &#125;&#125; 复杂度分析粗略的看，两个枚举深度应该是$dep^2$，所以总复杂度是$n*dep^2$，如果是满的话肯定跑不过，不信你可以把maxdep直接改成500。所以每次只更新到maxdep这么神奇？由于我们每个子树中深度相同的点都并到了一起，所以我们每个子树合并时可以看成两条链合并，当短的这条链合并到长的这条链时直接被吃掉了，因为它被合并到了一个和他深度相同的点上去了。例如这边的这个红点，当他与这条绿链合并时，被这个蓝点吃掉了，所以当我们在把左边这个子树与黄链合并的时候，红点和蓝点会同时和左边形成贡献，所以可以看做红点被蓝点吃掉了。那么我们再来考虑总贡献次数，每个点都会在被吃掉前与吃掉它的那一条链上的每个点形成以的贡献，所以总复杂度就是点数*最长链的长度了，即$n*maxdep$，所以树形dp事实上的复杂度是正确的。 结语这道树形dp本身不难，但是这种通过每个点的贡献来分析复杂度的方法还是很值得学习的]]></content>
      <categories>
        <category>题目分析</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F11%2F26%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[NOIP2018游记前言今天说要写游记，机房的大佬们问我为什么现在才写，估计是因为以前也没写过不知道怎么写，而且今天正式才成绩出来，算是尘埃落定了吧。 day-1以前所有的open day都不幸的被关在家里，这次这么好的机会当然要好好利用啦，结果不知是喝了咖啡还是自己过于兴奋，实在是睡不着，凌晨四点才好不容易落入了梦乡，没想到六点钟准时被生物钟叫起，只睡了两个小时，好困啊。。。。 day0起床了当然是去机房颓颓颓啦，和同学LOL五黑还是非常开心，狼人杀玩的也是非常的舒服啊。晚上回家吃了晚饭就开始重新敲模板，敲到八点钟感觉会考的基本都敲过了，刚好前一天实在是睡不够就赶紧睡了。 day1呀，我怎么又醒了，有了前一天的阴影，突然醒过来的我很是慌张，一看手表，呼，吓死了，6点了，顺便就起床了。果然前一天晚上睡得足精神就是好啊，再复习了一遍快读就和zx大佬一起参观学军紫金港的校园。学紫的校园确实是很漂亮啊，给人一种非常大气的感觉，只是操场是300米的有点小遗憾了。进了考场，先开始写快读，第一遍还写挂了。开题，这个T1好熟悉啊，感觉做过，碰巧前几天做了一道非常像的题，那道题的正解是单调栈，而我是用rmq+分治做的，仔细一想分治确实可以做，就开始写，写了一会儿觉得D1T1不至于这么难吧，肯定有更简单的做法，冷静了一下发现和前面一个比一下就好了，5min写完过了大样例，（出了考场经过交流得知，被我bibi过那题的yx大佬真的去写了rmq，当然yx大佬是不可能写挂的啦）。看了一眼T2没什么思路，先看T3吧，反正为时尚早。一看T3，诶，这不是裸的树形dp吗，（果然睡得好脑子就清醒）一算复杂度两个log而且应该很不满，赶紧写啊，大概20min写完了也过了大样例。再回过头看T2，好像结论还是蛮明显的，模型转化后就是一个完全背包诶，15min写完，这个时候大概是10点的样子，有了上次JSOI终场前5min打扫雷被教练婊的经历，想想还是多检查检查吧，毕竟联赛可是一道做对不得分，做错直接不及格的题啊。T1和T2的结论一遍一遍的想，觉得应该是没问题了。T3看了几遍，突然发现有一种特殊情况没有判到，真的是吓死了，赶紧改过来，经过这么一搞我更加不敢松懈了，又一遍一遍的开始检查，好在没有再吓自己一次。检查到11点半觉得应该没啥问题了，检查读写，再跑一遍样例，都没问题，那就这样了吧。胡思乱想到考试结束，出了考场和大家一起吃饭，果然大佬们都ak了，而且都比我早。。。下午回到了家和妈汇报了一下情况，她也很开心，我说到检查出错误的时候她也给我吓了一跳。等到洛谷自测数据出来，默了一下代码，确实是ak了，这口气算是松下来了。正想早点睡觉，结果水UOJ群的时候看到头文件不包cstdio会ce，在洛谷在线IDE上试了一下好像确实是会ce的，而本机没问题。我突然开始慌了，day1爆0那真的凉了，9点上的床，自己吓自己吓到11点才睡着，后来发现其实考场上的电脑不包的话过不来编译，完全是自己吓自己。 day2前一天过于紧张为今天的爆炸埋下了伏笔。看了一眼T1，树的60分很简单，后面40分环套树，估计又是分类讨论，平常被神仙题虐太多了，根本没注意到数据范围是给n^2的，只要枚举哪条边不走就行了，我尝试着写了一下线性发现非常难写，没事先搁着，如果后面有更好拿的分不如先去拿到，事后证明这时候的决策确实是非常明智的。一看后面两题，根本没有思路，T2刚了大约有两个小时，后来发现是错的，好在这其中还是发现了不少性质，拿到了50分的暴力分，T3的44分树形dp非常裸，很快的写完，这时大概是11点20左右，我发现T1还是想不清楚，无奈之下写了个12分的暴力然后开始尝试多拿T2，T3的暴力分，无奈T1的12分写的有点久，生怕自己犯低级错误，放弃了多拿8分的机会，选择检查（现在想想有点佩服自己当时的决策，机房某大佬T2就忘了打读写。。。），确认没有犯低级错误后11点55分了。走出考场，发现大家都想到T1的n方做法了，哎，还是自己太菜 ，和大家分享了自己的考试经历后，被大佬称赞心态真好，能这么冷静的分析。车上发现好多大佬也是被神仙题虐多了，T1都写了线性的，但我仍然觉得自己的决策是正确的（结果他们居然都不同程度的fst了。。。有的还不如我这个72分） day3程序发下来，day1的cstdio惊魂确实是自己吓自己，但没有发现D2T2的数据范围是小于等于的，而我看成了等于，所有n=1的点都没有判，收到了5-15分不等的损失，而且在机房大佬把全省成绩测出来之后发现100+100+100+72+50(-5~15)+44这个分一等奖大概是有的，但是能不能上pkuwc还不好说，算了，反正考完了，晚上吃了顿大餐，调整好心态，回归文化课学习。 day n出成绩了，ccf是在是太给面子了，n=1的点一个都没有放，成功得到466，虽然算不上很高，但比起我初三时算是很大的进步了，而且听教练说这分应该能上pkuwc，那我就不慌了，接下来继续好好努力争取冬令营考出好成绩吧。 结语在自己傻逼不会做D2T1的情况下，这个分数算是很理想了，而且是机房中为数不多得到期望分数的生，还是得益于自己的策略吧，希望以后的每次考试都能冷静的制定得分最大化的策略，不要留有遗憾。仅以此篇游记纪念NOIP2018之行，再接再厉。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性基学习笔记]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言首先讲一下线性基是什么东西，线性基是一个集合，你在原集合中找到一个子集，子集中的数xor起来一定能在线性基中找一个对应子集的xor和与其相等。比如说，{x,y}和{x,x^y} 就满足这么样一个关系。 原理我们把这个扩展一下，比如说我们现在有一个集合A，我新加进来一个数a，那么a与A中的数xor一下肯定是没有问题的。 性质定义一个数的M值为他二进制上第一个1出现的位置。 我们每往线性基中插入一个数，我们要让这个数的M值与之前线性基中的每一个数的M值都不同。 插入那么如何实现呢？1234567891011void insert(LL c)&#123; for (int i=51;i&gt;=0;i--)&#123; if (c&amp;bit[i])&#123; if (!xxj[i])&#123; xxj[i]=c; break; &#125; c=c^xxj[i]; &#125; &#125;&#125; 在这里，xxj[i]表示目前线性基中M值为i的这个数是多少。那么当我们新插入一个数C我们从大到小枚举C的每一个二进制位，如果当前位置上为1，如果对应的xxj[i]没有数，那么这个数就变成xxj[i]，否则xor上xxj[i]，通过我们前面的原理，这样正确性是对的，而且这样我们再扫后面的位置时，保证出现的1就是第一个出现的例：xxj[3]=101xxj[2]=0插入110110—&gt;11所以插入xxj[2]的时候M值已经为2了（这个应该比较好想） 那么我们就完成了线性基的插入，基于二进制位，所以插入的复杂度是log的，而且通过这种插入方式，我们线性基的大小就是基于二进制的位数了，log个。 合并合并两个线性基只需要把一个线性基暴力插入另一个即可，复杂度：线性基大小*插入复杂度，log方 删除这种不加特技的线性基不支持删除操作 取最大值我们从最高位倒着扫下来，扫到第i位，如果当前的答案ans这一位上为1，那么我们xor上xxj[i]一定只会变小，而且这个影响无法消除，因为xxj[i+1..n]都不可能在那ans第i位上变为1，（根据xxj[i]的性质），同理，如果ans这一位上位0，那么xor上ans[i]一定会让答案变大。当然如果xxj[i]==0,那就没有影响1234567LL query_max()&#123; LL ret=0; for (int i=51;i&gt;=0;i--)&#123; if ((xxj[i]^ret)&gt;ret) ret=ret^xxj[i]; &#125; return ret;&#125; 取xor d的最大值那么只需要把ret的初值赋为d就行了，原理也和上面的相同 取最小值只需要找到最小的i，且xxj[i]不等于0就行了 取k小值乍一看，一般的线性基好像不可做，问题在哪儿？10000010000001同时选1和2比只选1要差，所以我们无法做 但是如果线性基长成这样10000000100000001000000010000000100那么就好做了，因为选取1和2一定比只选1要优。 所以我么需要对原来的线性基rebuild一下，使得它变成上面那样的形式，当然100001001000010000101这种形式也是可以的，xxj[最后一位]上没有数，所以同时选2和3也比只选2优，尽管最后一位上的1被消掉了所以我们要使得若xxj[i]!=0，那么线性基里其他的数第i位上都为0，所以我们只需要拿xxj[i]去xor一下那些数就好了。rebuild之后的线性基怎么做：把k转成二进制，若k的第i位为1，那么将ans xor 上rebuild后第i大的xxj就行了。1234567891011121314151617181920void rebuild()&#123; for (int i=60;i&gt;=0;i--) for (int j=i-1;j&gt;=0;j--) if (d[i]&amp;(1LL&lt;&lt;j)) d[i]^=d[j]; for (int i=0;i&lt;=60;i++) if (d[i]) p[cnt++]=d[i];&#125;long long kthquery(long long k)&#123; int ret=0; if (k&gt;=(1LL&lt;&lt;cnt)) return -1; for (int i=60;i&gt;=0;i--) if (k&amp;(1LL&lt;&lt;i)) ret^=p[i]; return ret;&#125; 以上就是我对线性基的一些个人理解，希望能帮助大家学习，谢谢同时在此感谢Yveh的博客给了很大帮助。也感谢同学给予的帮助zhouyuheng2003]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笛卡尔树的妙用]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言笛卡尔树，与Treap类似，每个节点拥有两个值，key值和val值。key值是这个节点本身的大小值，在一颗treap中满足二叉查找树的性质，而val值则是一个随机值，学过treap的同学都知道，这个val值是拿来使得树的层高是期望log的，val值满足堆的性质，这里以小根堆为例讲解（当然大根堆不会有任何问题）。 应用一般笛卡尔树都被用来建一颗treap，复杂度为O(n)的，n表示插入的元素个数。而暴力插入的话是O(n log n)的。这里需要讲清楚的是，笛卡尔树建树，插入的元素必须保证key值递增，而val值是可以乱的，许多博客里没有讲，这里必须要强调一下。 实现我们维护笛卡尔树的极右链，就是根，根的右儿子，根的右儿子的右儿子…….放在一个栈里，栈底是根，这样很显然从栈顶到栈底，val值是不断变小的。每当我们进入一个新的节点，我们从栈顶开始找，当找到第一个节点的val值比我小，那么我必须得是它的儿子，而我的key值又比他大，所以我作为它的右儿子，而原先它的右儿子key值比我小，所以作为我的左儿子，这样就维护了一个treap的性质，然后原来那个店变为了我的左儿子，所以就要从极右链中删掉，我加入到极右链中，这样每个点进栈一次，出栈一次，复杂度就是O(n)的，下面贴出具体的代码。123456789for (int i=1;i&lt;=n;i++)&#123; read(key[i]),val[i]=rand(); while (top&amp;&amp;val[i]&lt;val[stack[top]])&#123; lson[i]=stack[top]; top--; &#125; if (top) rson[stack[top]]=i; stack[++top]=i;&#125; 以上就是笛卡尔树线性建treap的全部过程，希望对大家的学习有帮助]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚树学习笔记]]></title>
    <url>%2F2018%2F11%2F25%2F%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言先贴一道模板题 Luogu 2495题意，给你一棵n个点的有边权树，有m次询问，每次询问k个点，要删除一些边使得这k个点均不与1号点联通。数据范围：$2\le n\le250000,m\ge1,\sum k_i\le500000,1\le ki\le n-1$；考虑树形dp1234567891011121314LL get_ans(int u)&#123; bool leaf=1; LL ret=0; for (int p=head[u];p;p=nxt[p])&#123; ret+=get_ans(a[p]); leaf=0; &#125; head[u]=0; if (del[u])&#123; del[u]=0; return ff[u]; &#125; return min(ret,1ll*ff[u]);&#125; ff表示我连向我父亲的边的边权。我是直接暴力dfs一遍，如果我这个点要删除，那么一定是删我的ff边最优。否则选择删我ff边或者一个一个删我的子节点 这样dp一遍是O(n)的，但是m次询问就T了，但是注意到$\sum k$并不大，于是虚树闪亮登场了 介绍虚树就是把原树中少量的有效节点和他们两两的lca拿出来，这样就可以去除一些无效节点，从而降低复杂度。如果有效节点是k个，那么虚树中节点的个数是2*k个，为什么，请看下文。 实现先讲讲如何建虚树，在本题中，虚树上的边权就是原先这条路径上边权的min，因为你要删肯定是删最小边最优。先dfs一遍，求出基本信息。123456789101112void dfs(int u)&#123; dfn[u]=++tim; for (int p=head[u];p;p=nxt[p])&#123; int v=a[p]; if (v!=f[u][0])&#123; f[v][0]=u; minn[v][0]=b[p]; dep[v]=dep[u]+1; dfs(v); &#125; &#125;&#125; 先倍增求lca预处理好，倍增的时候最小值也处理好123456789101112131415161718192021222324for (int j=1;j&lt;=20;j++)&#123; for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], minn[i][j]=min(minn[i][j-1],minn[f[i][j-1]][j-1]);&#125;int lca(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); int tmp=dep[x]-dep[y]; for (int i=0;i&lt;=20;i++)&#123; if (tmp&amp;(1&lt;&lt;i)) x=f[x][i]; &#125; if (x==y) return x; for (int i=20;i&gt;=0;i--)&#123; if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; &#125; return f[x][0];&#125;int dist(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); int tmp=dep[x]-dep[y],ret=1e9; for (int i=0;i&lt;=20;i++)&#123; if (tmp&amp;(1&lt;&lt;i)) ret=min(ret,minn[x][i]),x=f[x][i]; &#125; return ret;&#125; 然后把所有有效点按照dfn值排序，每次新加入一个节点，他最多会和前面的一个节点产生一个lca。简单证明一下，设当前加入的节点x，与y节点产生了一个新的lca,lca1。假设x还与z产生了一个新的lca,lca2，不妨假设dep[lca2]&gt;deplca1个的。 构建虚树维护一个栈，表示从根到栈顶元素的这条链我们新加入一个节点记为x，链的末端，即栈顶，为p，lca为lca(x,p)，有两种情况: 1.p和x分立在lca的两棵子树下. 2.lca是p. 为什么lca不能是x? 因为如果lca是x,说明dfn[lca]=dfn[x]$ &lt; $dfn[p],而我们是按照dfs序号遍历的,于是dfn[p]$ &lt;$dfn[x],矛盾.) 对于第二种情况,直接在栈中插入节点x即可,不要连接任何边(后面会说为什么).对于第一种情况,要仔细分析.我们是按照dfn遍历的(因为很重要所以多说几遍……),有dfn[x]&gt;dfn[p]&gt;dfn[lca].这说明什么呢? 说明一件很重要的事:我们已经把lca所引领的子树中,p所在的子树全部遍历完了!简略的证明:如果没有遍历完,那么肯定有一个未加入的点h,满足dfn[h]$ &lt;$dfn[x],我们按照dfs序号递增顺序遍历的话,应该把h加进来了才能考虑x.这样,我们就直接构建lca引领的,p所在的那个子树. 我们在退栈的时候构建子树.p所在的子树如果还有其它部分,它一定在之前就构建好了(所有退栈的点都已经被正确地连入树中了),就剩那条链.如何正确地把p到lca那部分连进去呢?设栈顶的节点为p,栈顶第二个节点为q.重复以下操作: 如果dfn[q]&gt;dfn[lca],可以直接连边$q\to p$,然后退一次栈. 如果dfn[q]=dfn[lca],说明q=lca,直接连边$lca\to p$,此时子树已经构建完毕. 如果dfn[q]&lt;dfn[lca],说明lca被p与q夹在中间,此时连边$lca\to p$,退一次栈,再把lca压入栈.此时子树构建完毕最后,为了维护dfs链,要把x压入栈. 整个过程就是这样 上面这个讨论的过程来自chenhuan001的博客，把一些有小错误的地方改正了，我就是看着这个学会的，讲的非常清楚。还不明白的可以结合代码1234567891011121314151617void insert(int x)&#123; if (!top)&#123; st[++top]=x; return; &#125; int ll=lca(st[top],x); while (dep[st[top-1]]&gt;dep[ll]&amp;&amp;top&gt;1)&#123; add(st[top-1],st[top],dist(st[top-1],st[top])); top--; &#125; if (dep[ll]&lt;dep[st[top]])&#123; add(ll,st[top],dist(ll,st[top])); top--; &#125; if (!top||dep[st[top]]&lt;dep[ll]) st[++top]=ll; st[++top]=x;&#125; 那我们把虚树建出来后，用最前面讲的dp跑一边就好了。好了,以上就是我个人对虚树的一些理解，希望可以帮助大家学习，如果还有疑问可以给我留言，或者到我好友的博客看更详细的代码和建树过程的描述。https://blog.csdn.net/zhouyuheng2003/article/details/79110326谢谢。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树形dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈矩阵乘法的应用]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%B5%85%E8%B0%88%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言矩阵乘法，常常被用作递推式的优化，如果把一个递推式一步的递推转换成乘上一个矩阵，那么由于矩阵乘法有结合律，所以我们就可以快速幂啦，起到优化的效果。而递推式出现最多的地方当然就是dp了，所以今天想简单的总结一下矩阵乘法优化dp。 正文博主做的题比较少，见到的这类题也比较少，但有一道题感觉还是比较经典的。给出一张有向图，问从1号点出发，走过路径长度为T，到达n号点的方案数，其中$T\le 2e9$，每条边的边权均为1，$n\le100$。 那么显然有dp，$f[i][j]$表示到第j个点，当前走过的路径长度为i的方案数，那么我们枚举j的所有出边，设终点为k，则$f[i+1][k]+=f[i][j]$。但是这样子不方便我们理解矩阵乘法，我换一种dp方式，$f[i][j][k]$表示从j到k走了i条边的方案数，然后我们把给我们的邻接矩阵定义为map好了，那么首先$f[1][j][k]$就对应了map对吧，因为你只能走一步，当然只能走map上的边咯。接下来我们考虑转移，我们$f[i][j][k]$能由什么得到，我们显然是从k出发倒退一步对吧，假设上一步我们是$p\to k$，那么$f[i-1][j][p]\to f[i][j][k]$对吧，我们把这个dp的式子用代码写出来。123456789for (int i=1;i&lt;=T;i++)&#123; for (int j=1;j&lt;=n;j++)&#123; for (int k=1;k&lt;=n;k++)&#123; for (int p=1;p&lt;=n;p++)&#123; if (map[p][k]==1) f[i][j][k]+=f[i-1][j][p]; &#125; &#125; &#125;&#125; 然后神奇的事情就要发生了，我们把这个式子变一下形123456789for (int i=1;i&lt;=T;i++)&#123; for (int j=1;j&lt;=n;j++)&#123; for (int k=1;k&lt;=n;k++)&#123; for (int p=1;p&lt;=n;p++)&#123; f[i][j][k]+=f[i-1][j][p]*map[p][k]; &#125; &#125; &#125;&#125; 如果map[p][k]是0的话*0没有影响，如果是1的话没有区别对吧。再仔细观察一下这个式子，是不是发现和矩乘的形式一模一样。我们把i单独拎出来，那么f[i]这个矩阵就是由f[i-1]这个矩阵乘上map矩阵得到的，是不是非常神奇，接下来问题就好办了。前面已经说过f[1]就是map，所以我们要求走T步，只要把map矩阵自乘T次得到ans，ans[1][n]就是最终答案了。 这道题经典就在于它的递推矩阵正是map矩阵本身，非常神奇，许多人知道这个结论，但是并不知道是怎么来的，希望上文能够帮助大家理解。 而其他题目dp的矩阵就因题而异了，博主由于水平的问题也讲不出更多了，然后有一道非常好的例题给大家安利一下。Luogu 1297SCOI2009 迷路简述一下题意，就是有一张有向图，每条边有边权，注意不再是1，但是边权的范围1..9，然后走T的长度，问从1到n的方案数。$T\le 1000000000$如果边权不是1的话，用上面的转移就不对了，那怎么办，数据范围这么大，不矩乘不行啊，而边权又这么小，我们是不是可以把边权变成1。我们把每个点x变成$x[1]…x[9]，map[x[i]][x[i+1]]=1$，然后如果$x\to y$有一条边权为t的边，我们就令$map[x[t]][y[1]]=1$，这样子我们就保证了从x走到y要花t的时间，然后边权也都被我们变成1了，这样我们再和上面一样做就行了。希望本文对大家有帮助，以上全是基于博主的个人见解，如果有错误或者建议非常欢迎在评论留言，感激不尽。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演学习笔记]]></title>
    <url>%2F2018%2F11%2F23%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言停更好久了，刚好我们老师讲了莫比乌斯反演，那我就来开数论这个天坑吧。 莫比乌斯反演比如说我们现在有一个函数$f(n)=\sum_{d|n}g(d)$假设f非常容易求得，但是g很难求，那么我们是不是可以通过f来求g呢$g(n)=\sum_{d|n}f(\frac{n}{d})*\mu(d)$然后$mu(d)$这个东西就是莫比乌斯函数，所以这个变换也叫莫比乌斯变换 关于莫比乌斯函数 若 $d=1$，则 $\mu(d)=1$ 若 $d=p_1*p_2*p_3*p_4*..*p_n$ (注意不是笔者偷懒，而是p的次数都是1，且都是互异的质数) 那么$\mu(d)=(-1)^{n}$ other wise $\mu(d)=0$莫比乌斯函数的性质 性质1 对于正整数n，有$\sum_{d|n}\mu(d)=[n=1]$中括号在这里表达bool表达式，如果满足中括号内的条件则为1，否则为0证明： n=1，根据定义，显然成立 n&gt;1，设$n=p_1^{x_1}*p_2^{x_2}*p_3^{x_3}*…*p_k^{x_k}$，也就是把n质因数分解那么d一定能表示为$p_1^{y_1}*p_2^{y_2}*p_3^{y_3}*…*p_k^{y_k}$，其中($0\le y_i\le x_i$)，那么根据定义，只要有一个y大于二，那么$\mu(d)=0$，没有贡献，所以我们只要考虑所有y均为0,1时的情况。我们假设这k个中有r个y=1，那么出现这种情况的方案数为$C_{k}^{r}$，总贡献为$C_{k}^{r}*(-1)^{r}$我们再把每个d的贡献加起来$\sum_{r=0}^{k}*C_{k}^{r}*(-1)^{r}$是不是觉得有点眼熟呢，没错，这就是我们的二项式定理，所以上式就等于$(1+(-1))^k=0$结论得证。 性质2莫比乌斯函数为积性函数证明：若有两个互质的数a,b我们把它们分别分解质因数$a=p_1^{x_1}*p_2^{x_2}*…*p_k^{x_k}$$b=q_1^{y_1}*q_2^{y_2}*…*q_t^{y_t}$由于a,b互质，$a*b=p_1^{x_1}*p_2^{x_2}*…*p_k^{x_k}*q_1^{y_1}*q_2^{y_2}*…*q_t^{y_t}$如果$\mu(a)==0或\mu(b)==0$为0，那么说明一定有一个x或y&gt;=2，那么$\mu(a*b)$也一定为0.若$\mu(a)$与$\mu(b)$均为1，说明k与t均为偶数，那么k+t也为偶数，所以$\mu(a*b)$也为1若$\mu(a)$与$\mu(b)$均为-1，说明k与t均为奇数，那么k+t为偶数，所以$\mu(a*b)$为1若$\mu(a)为1，\mu(b)$为-1，说明k为偶数，t为奇数，那么k+t为奇数，所以$\mu(a*b)$为-1，$\mu(b)为1，\mu(a)$为-1与上一条同理。综上所述，莫比乌斯函数为积性函数。 莫比乌斯函数的求法这里介绍一下如何使用线性筛筛出莫比乌斯函数1234567891011121314151617memset(isprime,1,sizeof(isprime));isprime[1]=0;mu[1]=1;for (int i=2;i&lt;=100000;i++)&#123; if (isprime[i])&#123;prime[++pri]=i;mu[i]=-1;&#125;//质数的mu显然是-1 for (int j=1;j&lt;=pri&amp;&amp;i*prime[j]&lt;=100000;j++)&#123; int tt=i*prime[j]; isprime[tt]=0; if (i%prime[j]==0)&#123;//说明prime[j]这个质因子次数大于1，所以mu为0 mu[tt]=0; break; &#125; else&#123; mu[tt]=-mu[i];//说明新出现了一个质数，所以要再*=-1 &#125; &#125;&#125; 其复杂度就是线性筛的复杂度，和筛质数，筛phi都是一样的。 莫比乌斯反演我们现在已经知道了莫比乌斯函数和他的一些性质，那么我们试着证明一下莫比乌斯反演的正确性。 $g(n)=\sum_{d|n}f(\frac{n}{d})*\mu(d)$再把$f$展开 g(n)=\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}g(i)然后我们把g的sigma换到前面去 g(n)=\sum_{i|n}g(i)\sum_{d|\frac{n}{i}}\mu(d)我们考虑后面这个sigma的值1.当i=n时，$\sum_{d|\frac{n}{i}}\mu(d)=1，g(i)\sum_{d|\frac{n}{i}}\mu(d)=g(n)$2.当i为小于n且是n的因数时，根据$\sum_{d|n}\mu(d)=[n=1]$那么$\sum_{d|\frac{n}{i}}\mu(d)=0$，乘上一个g(i)仍然为0，那么上下两种情况加起来就是$\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}g(i)$所以就是g(n)，证毕 莫比乌斯反演的变形变形一：$f(i)=\sum_{d=1}^{\lfloor{\frac{n}{i}}\rfloor}g(d*i)—-&gt;g(i)=\sum_{d=1}^{\lfloor{\frac{n}{i}}\rfloor}f(d*i)*\mu(d)$证明：我们把上面二式的f展开$\sum_{d=1}^{\lfloor{\frac{n}{i}}\rfloor}f(d*i)*\mu(d)=\sum_{d=1}^{\lfloor{\frac{n}{i}}\rfloor}\mu(d)\sum_{d1=1}^{\lfloor{\frac{n}{d*i}}\rfloor}g(d1*d*i)$我们令d1*d=T那么原式=$\sum_{T=1}^{\lfloor{\frac{n}{i}}\rfloor}g(T*i)\sum_{d|T}\mu(d)$仔细想一下i,d,T的关系应该不难理解当(1)T=1时，$\sum_{d|T}\mu(d)=1，g(T*i)\sum_{d|T}\mu(d)=g(i)$(2)T&gt;1时，$\sum_{d|T}\mu(d)=0，g(T*i)\sum_{d|T}\mu(d)=0$综上所述，结论正确变形二：$f(i)=\sum_{i|d}g(d)—-&gt;g(i)=\sum_{i|d}f(d)*\mu(\frac{d}{i})$证明：另$\frac{d}{i}=k$那么$\sum_{i|d}f(d)*\mu(\frac{d}{i})=\sum_{k=1}^{\infty}\mu(k)*f(k*i)=\sum_{k=1}^{\infty}\mu(k)*\sum_{k*i|t}g(t)=\sum_{i|t}*g(t)*\sum_{k|\frac{t}{i}}\mu(k)$又是熟悉的套路，就是把$\mu$换成前缀和，就有非常好的性质了，那么最后得到的这个式子，只有在t=i时，后面的这个$\mu$的sigma才会变成1，所以加起来就是f(i)。 尾声以上就是笔者对莫比乌斯反演的一些理解与介绍，军训每天逃机房花了5天终于码完了，希望能给大家带来帮助]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[搞了三四天终于搭出了自己的博客，OI不一定能够成功，但至少留下这个博客可以怀念]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
</search>
